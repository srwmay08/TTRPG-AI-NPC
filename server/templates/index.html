<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bugbear Banter GM Interface</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; display: flex; height: 100vh; background-color: #f4f4f4; overflow: hidden; }
        .column { overflow-y: auto; box-sizing: border-box; }
        
        #left-column {
            width: 30%; /* Initial width */
            min-width: 300px; /* Increased min-width for better layout */
            max-width: 60%; 
            background-color: #e9e9e9;
            border-right: 1px solid #ccc;
            height: 100vh;
            padding: 0; 
            flex-shrink: 0; 
        }

        #left-column-content { padding: 15px; height: 100%; overflow-y: auto; box-sizing: border-box;}

        #resizer {
            width: 10px; 
            background-color: #d0d0d0;
            cursor: col-resize;
            border-left: 1px solid #ccc;
            border-right: 1px solid #ccc;
            user-select: none; 
            flex-shrink: 0;
        }
        #resizer:hover { background-color: #007bff; }

        #center-column {
            flex-grow: 1; 
            background-color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 15px;
            min-width: 0; 
        }

        .collapsible-section h3 { cursor: pointer; background-color: #d8d8d8; padding: 8px; margin: 10px 0 5px 0; user-select: none; position: relative; }
        .collapsible-section h3::after { content: ' ▼'; float: right; }
        .collapsible-section.collapsed .collapsible-content { display: none; }
        .collapsible-section.collapsed h3::after { content: ' ►'; }

        h2, h3, h4 { margin-top: 0; color: #333; }
        h5 { margin-top: 15px; margin-bottom: 5px; color: #333; border-bottom: 1px solid #eee; padding-bottom: 3px;}
        button { padding: 8px 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 5px; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #cccccc; cursor: not-allowed;}
        textarea, input[type="text"], input[type="number"], select { width: calc(100% - 16px); padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;}
        label { display: block; margin-bottom: 5px; font-weight: bold; }

        .character-list ul { list-style-type: none; padding: 0; max-height: 180px; overflow-y: auto; border: 1px solid #ddd; background: #fff; }
        .character-list li { 
            padding: 8px; 
            cursor: default;
            border-bottom: 1px solid #ddd; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        .character-list li:last-child { border-bottom: none; }
        .character-list li.active-in-scene { background-color: #e6f2ff; } 
        .character-list li .npc-name-clickable { flex-grow: 1; cursor: pointer; }
        .character-list li .npc-name-clickable:hover { text-decoration: underline; color: #0056b3;}


        #dialogue-interface { display: none; flex-grow: 1; display: flex; flex-direction: column; }
        #multi-npc-dialogue-container { flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; }
        .npc-dialogue-area { border: 1px solid #ddd; padding: 10px; border-radius: 5px; background-color: #f9f9f9;}
        .npc-dialogue-area h3 { margin-top: 0; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #eee;}
        .npc-transcript { min-height: 100px; max-height: 250px; overflow-y: auto; border: 1px solid #eee; padding: 8px; background-color: #fff; margin-bottom: 10px;}
        
        .dialogue-entry { margin-bottom: 8px; padding: 5px; border-radius: 3px; }
        .player-utterance { background-color: #e1f7d5; text-align: right; }
        .npc-response { background-color: #ddebf7; }
        .scene-event { font-style: italic; color: #777; text-align: center; margin:10px 0; }

        .memory-item, .suggested-item { background-color: #fff; border: 1px solid #eee; padding: 5px; margin-bottom: 5px; border-radius: 3px; font-size:0.9em; display: flex; justify-content: space-between; align-items: center; }
        .memory-item button, .suggested-item button { font-size: 0.8em; padding: 3px 6px; margin-left: 5px; }
        .clickable-suggestion { cursor: pointer; text-decoration: underline; color: blue; }
        
        #pc-dashboard-view { display: block; flex-grow: 1; overflow-y: auto; }
        .pc-dashboard-grid { display: flex; flex-wrap: wrap; gap: 15px; margin-top: 10px; margin-bottom: 20px; } 
        .pc-stat-card { border: 1px solid #ddd; border-radius: 4px; padding: 10px; background-color: #f9f9f9; flex: 1 1 200px; min-width: 180px; box-sizing: border-box; } 
        .pc-stat-card h4 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-bottom: 8px; font-size: 1.1em; }
        .pc-stat-card p { margin: 4px 0; font-size: 0.9em; }
        
        #main-stats-table, #skills-overview-table { width: 100%; border-collapse: collapse; margin-bottom: 15px; font-size: 0.9em; }
        #main-stats-table th, #main-stats-table td,
        #skills-overview-table th, #skills-overview-table td { border: 1px solid #ddd; padding: 6px; text-align: center; }
        #main-stats-table th, #skills-overview-table th { background-color: #e9ecef; font-weight: bold; }
        #main-stats-table td:first-child { text-align: left; font-weight: bold; } 
        #skills-overview-table th:first-child { text-align: left; font-weight: bold; } 
        #skills-overview-table td:first-child { text-align: left; font-weight: bold; } 

        
        .clickable-ability-header, .clickable-skill-header { cursor: pointer; color: #0056b3; text-decoration: underline;}
        .clickable-ability-header span.arrow-indicator, .clickable-skill-header span.arrow-indicator { font-size: 0.8em; margin-left: 3px;}

        .expanded-ability-content, .expanded-skill-content {
            border: 1px solid #ccc;
            padding: 15px;
            margin-top: 0px; 
            margin-bottom: 10px;
            background-color: #f8f9fa;
            border-top: none; 
        }
        .expanded-ability-content h5, .expanded-skill-content h5 { margin-top:10px; margin-bottom: 5px; border-bottom: 1px solid #eee; padding-bottom: 3px;}
        
        .ability-bar-chart-container, .skill-bar-chart-container { margin-bottom: 15px; padding: 10px; background-color: #fff; border: 1px solid #eee; border-radius: 4px;}
        .pc-bar-row { display: flex; align-items: center; margin-bottom: 3px; font-size: 0.9em; }
        .stat-comparison-pc-name { width: 120px; text-align: right; margin-right: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .stat-bar-wrapper { 
            flex-grow: 1; 
            background-color: #e0e0e0; 
            border-radius: 3px; 
            height: 18px; 
            min-width: 150px; 
            position: relative;
            overflow: hidden; 
        }
        .stat-bar-wrapper::before { 
            content: '';
            position: absolute;
            left: var(--zero-offset, 25%); 
            top: 0;
            bottom: 0;
            width: 1px;
            background-color: #bbb;
        }
        .stat-bar { 
            height: 100%; 
            background-color: #007bff; 
            border-radius: 3px; 
            color: white; 
            line-height: 18px; 
            font-size: 0.8em; 
            white-space: nowrap; 
            overflow: hidden; 
            position: absolute; 
            top: 0;
            box-sizing: border-box;
        }
        .stat-bar.positive {
            left: var(--bar-left);
            width: var(--bar-width);
            text-align: right; 
            padding-right: 5px; 
        }
        .stat-bar.negative {
            left: var(--bar-left); 
            width: var(--bar-width);
            background-color: #dc3545; 
            text-align: left; 
            padding-left: 5px; 
        }


        .derived-stats-table { width: 100%; border-collapse: collapse; font-size: 0.9em; margin-top:5px; margin-bottom: 15px; }
        .derived-stats-table th, .derived-stats-table td { border: 1px solid #ddd; padding: 5px; text-align: left; }
        .derived-stats-table th { background-color: #f1f1f1; font-weight: normal; }
        .derived-stats-table td { text-align: center; }
        .derived-stats-table th:first-child { font-weight: bold; text-align: left; width: 180px;}

        .rules-explanation-table { width: 100%; border-collapse: collapse; margin-top: 5px; margin-bottom: 10px; font-size: 0.9em; background-color: #fff; }
        .rules-explanation-table td { border: 1px solid #e0e0e0; padding: 8px; }
        .rules-explanation-table ul { margin-top: 0; margin-bottom: 0; padding-left: 20px; }
        .rules-explanation-table strong { color: #333; }
        .pc-dashboard-no-selection { text-align: center; color: #777; margin-top: 50px; font-size: 1.2em;}

        /* Styles for history content display */
        #history-content-display {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            max-height: 300px; 
            overflow-y: auto;
            white-space: pre-wrap; 
            font-family: 'Courier New', Courier, monospace; 
            font-size: 0.9em;
        }
        #associated-history-list {
            list-style-type: none;
            padding-left: 0;
        }
        #associated-history-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        #associated-history-list li:last-child {
            border-bottom: none;
        }
        .remove-history-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
        }
        .remove-history-btn:hover {
            background-color: #c82333;
        }

    </style>
</head>
<body>

    <div id="left-column" class="column">
        <div id="left-column-content">
            <h2>Characters & Details</h2>
            
            <div id="pc-list-section" class="collapsible-section">
                <h3>Active Player Characters</h3>
                <div class="collapsible-content character-list">
                    <div id="active-pc-list"><p><em>Loading PCs...</em></p></div>
                </div>
            </div>
            <div id="npc-list-section" class="collapsible-section">
                <h3>NPCs in Scene</h3>
                <div class="collapsible-content character-list">
                    <div id="character-list"><ul><li><em>Loading NPCs...</em></li></ul></div>
                </div>
            </div>

            <div id="character-profile-main-section" class="collapsible-section">
                <h3>Profile: <span id="details-char-name">None</span></h3>
                <div class="collapsible-content">
                    <div id="char-profile-display">
                        <p><strong>Type:</strong> <span id="profile-char-type"></span></p>
                        <p><strong>Description:</strong> <span id="profile-description"></span></p>
                        <p><strong>Personality:</strong> <span id="profile-personality"></span></p>
                    </div>
                    <div id="gm-notes-collapsible-section" class="collapsible-section">
                        <h3>GM Notes</h3>
                        <div class="collapsible-content">
                            <textarea id="gm-notes" rows="3" placeholder="Private notes for this character..."></textarea>
                            <button onclick="saveGMNotes()" id="save-gm-notes-btn" disabled>Save Notes</button>
                        </div>
                    </div>
                    <div id="npc-memories-collapsible-section" class="collapsible-section">
                        <h3>NPC Memories</h3>
                        <div class="collapsible-content" id="npc-specific-details-content">
                            <div id="add-memory-form">
                                <label for="new-memory-content">Add Custom Memory:</label>
                                <input type="text" id="new-memory-content" placeholder="Fact, event, observation...">
                                <input type="text" id="new-memory-type" placeholder="Type (e.g., fact, seen)">
                                <button onclick="addMemoryToCharacter()" id="add-memory-btn" disabled>Add Memory</button>
                            </div>
                            <div id="character-memories-list"></div>
                        </div>
                    </div>
                    <div id="character-history-collapsible-section" class="collapsible-section collapsed">
                        <h3>Character History</h3>
                        <div class="collapsible-content">
                            <label for="history-file-select">Available History Files to Add:</label>
                            <select id="history-file-select">
                                <option value="">-- Select a history file --</option>
                            </select>
                            <button onclick="associateHistoryFile()" id="associate-history-btn" disabled>Add Selected History</button>
                            
                            <h5>Currently Associated Files:</h5>
                            <ul id="associated-history-list">
                                <li><em>None associated.</em></li>
                            </ul>
                            
                            <h5>History Content:</h5>
                            <div id="history-content-display">
                                <p><em>No history content loaded. Associate files to view their content.</em></p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="create-character-section" class="collapsible-section collapsed">
                <h3>Create New Character</h3>
                <div id="create-character-form" class="collapsible-content">
                    <label for="new-char-name">Name:</label>
                    <input type="text" id="new-char-name" required>
                    <label for="new-char-description">Description:</label>
                    <textarea id="new-char-description" rows="3" required></textarea>
                    <label for="new-char-personality">Personality (comma-separated):</label>
                    <input type="text" id="new-char-personality">
                    <label for="new-char-type">Character Type:</label>
                    <select id="new-char-type">
                        <option value="NPC" selected>NPC (Non-Player Character)</option>
                        <option value="PC">PC (Player Character)</option>
                    </select>
                    <button onclick="createCharacter()">Create Character</button>
                </div>
            </div>
        </div>
    </div>

    <div id="resizer"></div>

    <div id="center-column" class="column">
        <div id="dialogue-interface">
            <h2>Scene Interaction</h2>
            <div id="scene-setup">
                <label for="scene-context">Dynamic Scene Context:</label>
                <textarea id="scene-context" rows="4" placeholder="Describe the current environment, mood, ongoing events..."></textarea>
            </div>
            <hr>
            <div id="multi-npc-dialogue-container">
                 <p class="scene-event">Select NPCs to add them to the scene.</p>
            </div>
            <hr>
            <div id="dialogue-input-area">
                <label for="player-utterance">Player Says (to all active NPCs):</label>
                <textarea id="player-utterance" rows="2" placeholder="Enter player dialogue here..."></textarea>
                <button onclick="generateDialogue()" id="generate-dialogue-btn" disabled>Send to NPCs</button>
            </div>
            <div id="ai-suggestions"> <h4>AI Suggestions:</h4>
                <div id="suggested-memories-list"></div>
                <div id="suggested-topics-list"></div>
            </div>
        </div>

        <div id="pc-dashboard-view">
            <h2>Player Character Dashboard</h2>
            <div id="pc-dashboard-content">
                <p class="pc-dashboard-no-selection">Select Player Characters from the left panel to view their details and comparisons.</p>
            </div>
        </div>
    </div>

<script>
    // --- Global State Variables ---
    let activeSceneNpcIds = new Set(); 
    let activePcIds = new Set(); 
    let allCharacters = [];
    let dialogueHistory = []; 
    let dialogueHistories = {}; 
    let currentProfileCharId = null; 
    let currentlyExpandedAbility = null; 
    let currentlyExpandedSkill = null; 
    let skillSortKey = null; 

    // --- Constants ---
    const API_BASE_URL = ''; 

    // --- Utility Functions ---
    function getElem(id) { return document.getElementById(id); }
    function updateText(id, text) { getElem(id).textContent = text; }
    function disableBtn(id, disabled) { getElem(id).disabled = disabled; }

    // --- D&D 5e Calculation Functions (Keep as is) ---
    function getAbilityModifier(score) { return Math.floor((score - 10) / 2); }
    function carryingCapacity(score) { return score * 15; }
    function pushDragLift(score) { return score * 30; } 
    function longJump(score, running = true) { return running ? score : Math.floor(score / 2); }
    function highJump(score, running = true) { const mod = getAbilityModifier(score); return running ? (3 + mod) : Math.floor((3 + mod) / 2); }
    function initiative(dexScore) { return getAbilityModifier(dexScore); }
    function holdBreath(conScore) { return Math.max(1 + getAbilityModifier(conScore), 0.5) + " minutes"; } 
    function spellSaveDC(castingStatScore, proficiencyBonus) { return 8 + getAbilityModifier(castingStatScore) + proficiencyBonus; }
    function spellAttackBonus(castingStatScore, proficiencyBonus) { return getAbilityModifier(castingStatScore) + proficiencyBonus; }
    function savingThrowBonus(abilityScore, proficientInSave = false, proficiencyBonus = 0) {
        const mod = getAbilityModifier(abilityScore);
        return mod + (proficientInSave ? proficiencyBonus : 0);
    }
    function calculateSkillBonus(baseStatScore, skillProficiencyValue, proficiencyBonus) {
        const modifier = getAbilityModifier(baseStatScore);
        let skillBonus = modifier;
        if (skillProficiencyValue === 1) { 
            skillBonus += proficiencyBonus;
        } else if (skillProficiencyValue === 2) {
            skillBonus += (proficiencyBonus * 2);
        } else if (skillProficiencyValue === 0.5) { 
            skillBonus += Math.floor(proficiencyBonus / 2);
        }
        return skillBonus;
    }
    function calculatePassiveSkill(baseStatScore, skillProficiencyValue, proficiencyBonus) {
        const skillBonus = calculateSkillBonus(baseStatScore, skillProficiencyValue, proficiencyBonus);
        return 10 + skillBonus; 
    }
    function getProficiencyBonus(level) {
        if (level < 1) return 2; 
        if (level <= 4) return 2;
        if (level <= 8) return 3;
        if (level <= 12) return 4;
        if (level <= 16) return 5;
        return 6;
    }

    // --- Character Data & Rendering ---
    async function fetchCharacters() {
        try {
            const response = await fetch(`${API_BASE_URL}/api/npcs`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            allCharacters = await response.json();
            renderNpcListForScene(); 
            renderPcList();
            updateView(); 
        } catch (error) { 
            console.error('Error in fetchCharacters:', error); 
            getElem('character-list').innerHTML = '<ul><li><em>Error loading NPCs. Check console.</em></li></ul>';
            getElem('active-pc-list').innerHTML = '<p><em>Error loading PCs. Check console.</em></p>';
        }
    }
    
    function renderNpcListForScene() {
        const listContainer = getElem('character-list'); 
        let ul = listContainer.querySelector('ul');
        if (!ul) { 
            ul = document.createElement('ul');
            listContainer.appendChild(ul);
        }
        ul.innerHTML = ''; 
        const npcs = allCharacters.filter(char => char.character_type === 'NPC');
        
        if (npcs.length === 0) { 
            ul.innerHTML = '<li><p><em>No NPCs defined yet. Create NPCs to add them to scenes.</em></p></li>'; 
            return; 
        }

        npcs.forEach(char => {
            const li = document.createElement('li');
            li.dataset.charId = char._id;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `npc-scene-checkbox-${char._id}`;
            checkbox.checked = activeSceneNpcIds.has(char._id);
            checkbox.onchange = () => toggleNpcInScene(char._id, char.name);
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = char.name;
            nameSpan.className = 'npc-name-clickable';
            nameSpan.onclick = () => {
                selectCharacterForDetails(char._id);
            };
            
            li.appendChild(checkbox);
            li.appendChild(nameSpan);
            
            if (activeSceneNpcIds.has(char._id)) {
                li.classList.add('active-in-scene');
            }
            ul.appendChild(li);
        });
    }

    function toggleNpcInScene(npcId, npcName) {
        const multiNpcContainer = getElem('multi-npc-dialogue-container');
        if (activeSceneNpcIds.has(npcId)) {
            activeSceneNpcIds.delete(npcId);
            removeNpcDialogueArea(npcId);
            delete dialogueHistories[npcId]; 
        } else {
            activeSceneNpcIds.add(npcId);
            createNpcDialogueArea(npcId, npcName);
            dialogueHistories[npcId] = []; 
        }
        
        if (activeSceneNpcIds.size >= 1 && multiNpcContainer.querySelector('p.scene-event')) {
            multiNpcContainer.innerHTML = ''; 
            activeSceneNpcIds.forEach(id => { 
                 const npc = allCharacters.find(c=> c._id === id);
                 if(npc && !getElem(`npc-area-${id}`)) { 
                    createNpcDialogueArea(id, npc.name);
                 }
            });
        } else if (activeSceneNpcIds.size === 0) {
             multiNpcContainer.innerHTML = '<p class="scene-event">Select NPCs to add them to the scene.</p>';
        }

        renderNpcListForScene(); 
        disableBtn('generate-dialogue-btn', activeSceneNpcIds.size === 0);
        updateView(); 
    }

    function createNpcDialogueArea(npcId, npcName) {
        const container = getElem('multi-npc-dialogue-container');
        const placeholder = container.querySelector('p.scene-event');
        if (placeholder && activeSceneNpcIds.size > 0) { 
            placeholder.remove();
        }

        if (getElem(`npc-area-${npcId}`)) return; 

        const areaDiv = document.createElement('div');
        areaDiv.className = 'npc-dialogue-area';
        areaDiv.id = `npc-area-${npcId}`;

        const nameHeader = document.createElement('h3');
        nameHeader.textContent = npcName;
        areaDiv.appendChild(nameHeader);

        const transcriptDiv = document.createElement('div');
        transcriptDiv.className = 'npc-transcript';
        transcriptDiv.id = `transcript-${npcId}`;
        transcriptDiv.innerHTML = `<p class="scene-event">Dialogue with ${npcName} starts.</p>`;
        areaDiv.appendChild(transcriptDiv);
        
        container.appendChild(areaDiv);
    }

    function removeNpcDialogueArea(npcId) {
        const areaDiv = getElem(`npc-area-${npcId}`);
        if (areaDiv) {
            areaDiv.remove();
        }
        const container = getElem('multi-npc-dialogue-container');
        if (activeSceneNpcIds.size === 0 && !container.querySelector('p.scene-event')) {
             container.innerHTML = '<p class="scene-event">Select NPCs to add them to the scene.</p>';
        }
    }

    function renderPcList() {
        const pcListDiv = getElem('active-pc-list');
        pcListDiv.innerHTML = '';
        const pcs = allCharacters.filter(char => char.character_type === 'PC');
        if (pcs.length === 0) { 
            pcListDiv.innerHTML = '<p><em>No Player Characters defined yet. Create characters with type "PC".</em></p>'; 
            return; 
        }
        const ul = document.createElement('ul');
        pcs.forEach(pc => {
            const li = document.createElement('li');
            li.style.cursor = "pointer"; 
            li.textContent = pc.name;
            li.dataset.charId = pc._id;
            li.onclick = async () => { // Make the handler async
                activeSceneNpcIds.clear(); 
                getElem('multi-npc-dialogue-container').innerHTML = '<p class="scene-event">Select NPCs to add them to the scene.</p>';
                renderNpcListForScene(); 
                disableBtn('generate-dialogue-btn', true);

                togglePcSelection(pc._id, li); 
                
                // Await the completion of fetching and processing character details
                // This ensures 'allCharacters' is updated before 'updateView' and 'updatePcDashboard' use it.
                await selectCharacterForDetails(pc._id); 
                
                updateView(); // Now call updateView, which will show the PC dashboard with fresh data
            };
            if (activePcIds.has(pc._id)) li.classList.add('selected');
            ul.appendChild(li);
        });
        pcListDiv.appendChild(ul);
    }
    
    async function fetchHistoryFiles() {
        const selectElement = getElem('history-file-select');
        selectElement.innerHTML = '<option value="">-- Select a history file --</option>'; 
        try {
            const response = await fetch(`${API_BASE_URL}/api/history_files`);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Failed to fetch history files. Status: ${response.status}. Message: ${errorText}`);
            }
            const files = await response.json();
            files.forEach(file => {
                const option = document.createElement('option');
                option.value = file;
                option.textContent = file;
                selectElement.appendChild(option);
            });
        } catch (error) {
            console.error("Error in fetchHistoryFiles function:", error.message, error);
            selectElement.innerHTML += `<option value="" disabled>Error loading files.</option>`;
        }
    }

    async function associateHistoryFile() {
        if (!currentProfileCharId) {
            alert("Please select a character in the profile section first.");
            return;
        }
        const selectedFile = getElem('history-file-select').value;
        if (!selectedFile) {
            alert("Please select a history file from the dropdown to add.");
            return;
        }
        try {
            const response = await fetch(`${API_BASE_URL}/api/character/${currentProfileCharId}/associate_history`, {
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ history_file: selectedFile })
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: "Server returned non-JSON error response."}));
                throw new Error(errorData.error || errorData.message || 'Failed to associate history file.');
            }
            const result = await response.json(); // Expecting { message, character }
            alert(result.message || "History file associated successfully.");
            
            // Update local character data
            const charIndex = allCharacters.findIndex(c => c._id === currentProfileCharId);
            if (charIndex > -1) {
                allCharacters[charIndex] = result.character; // Replace with the full updated character from backend
            }
            // Re-render the history section for the current character
            selectCharacterForDetails(currentProfileCharId); 

        } catch (error) {
            console.error("Error associating history file:", error);
            alert(`Error: ${error.message}`);
        }
    }

    async function dissociateHistoryFile(filename) {
        if (!currentProfileCharId) {
            alert("No character selected.");
            return;
        }
        if (!confirm(`Are you sure you want to remove "${filename}" from this character's history?`)) {
            return;
        }
        try {
            const response = await fetch(`${API_BASE_URL}/api/character/${currentProfileCharId}/dissociate_history`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ history_file: filename })
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: "Server error during dissociation." }));
                throw new Error(errorData.error || errorData.message || "Failed to dissociate history file.");
            }
            const result = await response.json();
            alert(result.message || "History file dissociated successfully.");

            const charIndex = allCharacters.findIndex(c => c._id === currentProfileCharId);
            if (charIndex > -1) {
                allCharacters[charIndex] = result.character; // Update with full character data from backend
            }
            selectCharacterForDetails(currentProfileCharId); // Refresh display

        } catch (error) {
            console.error("Error dissociating history file:", error);
            alert(`Error: ${error.message}`);
        }
    }


    function renderAssociatedHistoryFiles(character) {
        const listElement = getElem('associated-history-list');
        listElement.innerHTML = ''; // Clear current list

        if (character && character.associated_history_files && character.associated_history_files.length > 0) {
            character.associated_history_files.forEach(filename => {
                const li = document.createElement('li');
                li.textContent = filename;
                
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'Remove';
                removeBtn.className = 'remove-history-btn';
                removeBtn.onclick = () => dissociateHistoryFile(filename);
                
                li.appendChild(removeBtn);
                listElement.appendChild(li);
            });
        } else {
            listElement.innerHTML = '<li><em>None associated.</em></li>';
        }

        // Display combined history content
        const historyContentDisplay = getElem('history-content-display');
        if (character && character.combined_history_content) {
            historyContentDisplay.textContent = character.combined_history_content;
        } else if (character && character.associated_history_files && character.associated_history_files.length > 0) {
            historyContentDisplay.textContent = "Loading content..."; // Or fetch content if not pre-loaded
        } else {
            historyContentDisplay.textContent = "No history content. Associate files to view their content.";
        }
    }


    function selectCharacterForDetails(charId) {
        currentProfileCharId = charId; 
        // Fetch the full character details, including loaded history, from the backend
        fetch(`${API_BASE_URL}/api/npcs/${charId}`)
            .then(response => {
                if (!response.ok) throw new Error(`Failed to fetch character details: ${response.status}`);
                return response.json();
            })
            .then(selectedChar => {
                // Update the allCharacters array with the fresh data (important for history content)
                const charIndex = allCharacters.findIndex(c => c._id === charId);
                if (charIndex > -1) {
                    allCharacters[charIndex] = selectedChar;
                } else {
                    allCharacters.push(selectedChar); // Should ideally not happen if charId came from existing list
                }

                updateText('details-char-name', selectedChar.name); 
                updateText('profile-char-type', selectedChar.character_type);
                updateText('profile-description', selectedChar.description || "N/A");
                updateText('profile-personality', (selectedChar.personality_traits || []).join(', ') || "N/A");
                
                getElem('gm-notes').value = selectedChar.gm_notes || '';
                disableBtn('save-gm-notes-btn', false);

                const isNpc = selectedChar.character_type === 'NPC';
                getElem('npc-memories-collapsible-section').style.display = isNpc ? 'block' : 'none';
                getElem('character-history-collapsible-section').style.display = 'block'; 
                
                if (isNpc) {
                    renderMemories(selectedChar.memories || []);
                    disableBtn('add-memory-btn', false);
                } else { 
                    disableBtn('add-memory-btn', true);
                    getElem('character-memories-list').innerHTML = '<p><em>Memories are typically managed for NPCs.</em></p>';
                }
                
                renderAssociatedHistoryFiles(selectedChar); // Display associated files and their content
                fetchHistoryFiles(); // Populate the dropdown for adding new files
                disableBtn('associate-history-btn', false);
            })
            .catch(error => {
                console.error("Error fetching character details:", error);
                currentProfileCharId = null;
                updateText('details-char-name', "Error");
                // Clear other fields
                getElem('history-content-display').textContent = "Error loading character details.";
                getElem('associated-history-list').innerHTML = '<li><em>Error loading.</em></li>';
            });
    }


    function togglePcSelection(pcId, element) {
        if (activePcIds.has(pcId)) {
            activePcIds.delete(pcId);
            element.classList.remove('selected');
        } else {
            activePcIds.add(pcId);
            element.classList.add('selected');
        }
        if(getElem('pc-dashboard-view').style.display !== 'none') { 
            if (currentlyExpandedAbility) {
                const expansionDiv = document.getElementById(`expanded-${currentlyExpandedAbility}`);
                const selectedPcsForExpansion = allCharacters.filter(char => activePcIds.has(char._id) && char.character_type === 'PC' && char.vtt_data);
                if (expansionDiv && expansionDiv.style.display === 'block') { 
                    if (selectedPcsForExpansion.length > 0) {
                        populateExpandedAbilityDetails(currentlyExpandedAbility, expansionDiv, selectedPcsForExpansion);
                    } else { 
                        expansionDiv.innerHTML = '<p>Select PCs to see details for this ability.</p>'; 
                    }
                }
            }
             if (currentlyExpandedSkill) { 
                const skillExpansionDiv = document.getElementById(`expanded-skill-${currentlyExpandedSkill}`);
                const selectedPcsForSkillExpansion = allCharacters.filter(char => activePcIds.has(char._id) && char.character_type === 'PC' && char.vtt_data);
                 if (skillExpansionDiv && skillExpansionDiv.style.display === 'block') {
                    if (selectedPcsForSkillExpansion.length > 0) {
                        populateExpandedSkillDetails(currentlyExpandedSkill, skillExpansionDiv, selectedPcsForSkillExpansion);
                    } else {
                        skillExpansionDiv.innerHTML = '<p>Select PCs to see details for this skill.</p>';
                    }
                }
            }
            updatePcDashboard(); 
        }
    }
    
    function updateView() {
        const dialogueInterface = getElem('dialogue-interface');
        const pcDashboardView = getElem('pc-dashboard-view');
        
        if (activeSceneNpcIds.size > 0) { 
            dialogueInterface.style.display = 'flex'; 
            pcDashboardView.style.display = 'none';
            if(currentlyExpandedAbility){ 
                const expansionDiv = document.getElementById(`expanded-${currentlyExpandedAbility}`);
                if(expansionDiv) expansionDiv.style.display = 'none';
                const headerTH = document.querySelector(`#main-stats-table th[data-ability="${currentlyExpandedAbility}"]`);
                if (headerTH) headerTH.querySelector('span.arrow-indicator').textContent = ' ►';
                currentlyExpandedAbility = null;
            }
            if(currentlyExpandedSkill){ 
                const skillExpansionDiv = document.getElementById(`expanded-skill-${currentlyExpandedSkill}`);
                if(skillExpansionDiv) skillExpansionDiv.style.display = 'none';
                const skillHeader = document.querySelector(`#skills-overview-table th.clickable-skill-header[data-skill-key="${currentlyExpandedSkill}"]`);
                if(skillHeader) skillHeader.querySelector('span.arrow-indicator').textContent = ' ►';
                currentlyExpandedSkill = null;
            }
        } else { 
            dialogueInterface.style.display = 'none';
            pcDashboardView.style.display = 'block';
            updatePcDashboard(); 
        }
    }
    
    function updatePcDashboard() {
        const dashboardContent = getElem('pc-dashboard-content');
        dashboardContent.innerHTML = ''; 

        const selectedPcs = allCharacters.filter(char => activePcIds.has(char._id) && char.character_type === 'PC' && char.vtt_data);

        if (selectedPcs.length === 0) {
            const anyPcsExist = allCharacters.some(char => char.character_type === 'PC' && char.vtt_data);
            dashboardContent.innerHTML = `<p class="pc-dashboard-no-selection">${anyPcsExist ? 'Select Player Characters from the left panel to view their details.' : 'No Player Characters with VTT data available. Create PCs and ensure VTT data is synced.'}</p>`;
            if (currentlyExpandedAbility) {
                const expansionDiv = document.getElementById(`expanded-${currentlyExpandedAbility}`);
                if (expansionDiv) expansionDiv.style.display = 'none';
                const headerTH = document.querySelector(`#main-stats-table th[data-ability="${currentlyExpandedAbility}"]`);
                if (headerTH) headerTH.querySelector('span.arrow-indicator').textContent = ' ►';
                currentlyExpandedAbility = null;
            }
            if (currentlyExpandedSkill) {
                const skillExpansionDiv = document.getElementById(`expanded-skill-${currentlyExpandedSkill}`);
                if (skillExpansionDiv) skillExpansionDiv.style.display = 'none';
                const skillHeader = document.querySelector(`#skills-overview-table th.clickable-skill-header[data-skill-key="${currentlyExpandedSkill}"]`);
                if (skillHeader) skillHeader.querySelector('span.arrow-indicator').textContent = ' ►';
                currentlyExpandedSkill = null;
            }
            return;
        }

        // --- Individual Quick Stat Cards ---
        let statCardsHTML = `<h4>PC Quick View</h4><div class="pc-dashboard-grid">`;
        const sortedSelectedPcsByName = [...selectedPcs].sort((a,b) => a.name.localeCompare(b.name));
        sortedSelectedPcsByName.forEach(pc => {
            const pcLevel = pc.flags?.ddbimporter?.dndbeyond?.totalLevels || pc.system?.details?.level || 1;
            const profBonus = getProficiencyBonus(pcLevel);
            statCardsHTML += `<div class="pc-stat-card"><h4>${pc.name} (Lvl ${pcLevel})</h4>`;
            const hpCurrent = pc.vtt_data.attributes.hp?.value !== undefined ? pc.vtt_data.attributes.hp.value : 'N/A';
            const hpMax = pc.vtt_data.attributes.hp?.max !== undefined && pc.vtt_data.attributes.hp.max !== null ? pc.vtt_data.attributes.hp.max : 'N/A';
            statCardsHTML += `<p><strong>HP:</strong> ${hpCurrent} / ${hpMax}</p>`;
            
            let acDisplay = pc.flags?.ddbimporter?.overrideAC?.flat; 
            if (acDisplay === undefined || acDisplay === null) {
                acDisplay = pc.vtt_data.attributes.ac?.value;
            }
            if (acDisplay === undefined || acDisplay === null) {
                acDisplay = pc.vtt_data.attributes.ac?.flat;
            }
            if (acDisplay === undefined || acDisplay === null) {
                acDisplay = 'N/A';
            }
            statCardsHTML += `<p><strong>AC:</strong> ${acDisplay}</p>`;
            
            let passivePercFormatted = 'N/A';
            const wisScoreForPassive = pc.vtt_data.abilities?.wis?.value;
            const percSkillInfo = pc.vtt_data.skills?.prc; 
            if (wisScoreForPassive !== undefined && percSkillInfo !== undefined) {
                passivePercFormatted = calculatePassiveSkill(wisScoreForPassive, percSkillInfo.value || 0, profBonus);
            }
            statCardsHTML += `<p><strong>Pas. Perception:</strong> ${passivePercFormatted}</p>`;

            let passiveInvFormatted = 'N/A';
            const intScoreForPassive = pc.vtt_data.abilities?.int?.value;
            const invSkillInfo = pc.vtt_data.skills?.inv; 
            if (intScoreForPassive !== undefined && invSkillInfo !== undefined) {
                 passiveInvFormatted = calculatePassiveSkill(intScoreForPassive, invSkillInfo.value || 0, profBonus);
            }
            statCardsHTML += `<p><strong>Pas. Investigation:</strong> ${passiveInvFormatted}</p>`;
            statCardsHTML += `</div>`;
        });
        statCardsHTML += `</div>`; 
        dashboardContent.innerHTML += statCardsHTML;

        // --- Main Ability Scores Overview Table ---
        const abilities = ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'];
        let mainStatsTableHTML = `<h4>Ability Scores Overview</h4>
                                  <table id="main-stats-table"><thead><tr><th>Character</th>`;
        abilities.forEach(ablKey => {
            const arrow = (currentlyExpandedAbility === ablKey && document.getElementById(`expanded-${ablKey}`)?.style.display !== 'none') ? '▼' : '►';
            mainStatsTableHTML += `<th class="clickable-ability-header" data-ability="${ablKey}" onclick="toggleAbilityExpansion('${ablKey}')">${ablKey} <span class="arrow-indicator">${arrow}</span></th>`;
        });
        mainStatsTableHTML += `</tr></thead><tbody>`;
        sortedSelectedPcsByName.forEach(pc => { 
            mainStatsTableHTML += `<tr><td>${pc.name}</td>`;
            abilities.forEach(ablKey => {
                const score = pc.vtt_data.abilities[ablKey.toLowerCase()]?.value || 0;
                const mod = getAbilityModifier(score);
                mainStatsTableHTML += `<td>${score} (${mod >= 0 ? '+' : ''}${mod})</td>`;
            });
            mainStatsTableHTML += `</tr>`;
        });
        mainStatsTableHTML += `</tbody></table>`;
        const abilityExpansionContainer = document.createElement('div');
        abilityExpansionContainer.id = 'expanded-ability-details-sections';
        dashboardContent.innerHTML += mainStatsTableHTML; 
        dashboardContent.appendChild(abilityExpansionContainer); 

        abilities.forEach(ablKey => {
            const expansionDiv = document.createElement('div');
            expansionDiv.id = `expanded-${ablKey}`;
            expansionDiv.className = 'expanded-ability-content';
            expansionDiv.style.display = (currentlyExpandedAbility === ablKey) ? 'block' : 'none';
            if (currentlyExpandedAbility === ablKey && selectedPcs.length > 0) {
                populateExpandedAbilityDetails(ablKey, expansionDiv, selectedPcs);
            }
            abilityExpansionContainer.appendChild(expansionDiv);
        });

        // --- Skills Overview Table (PCs as rows, Skills as columns) ---
        const skillNameMap = {
            "acr": "Acrobatics", "ani": "Animal Handling", "arc": "Arcana", "ath": "Athletics", 
            "dec": "Deception", "his": "History", "ins": "Insight", "itm": "Intimidation", 
            "inv": "Investigation", "med": "Medicine", "nat": "Nature", "prc": "Perception", 
            "prf": "Performance", "per": "Persuasion", "rel": "Religion", "slt": "Sleight of Hand", 
            "ste": "Stealth", "sur": "Survival"
        };
        let skillsTableHTML = `<h4>Skills Overview</h4>
                               <table id="skills-overview-table"><thead><tr><th>Character</th>`;
        for (const skillKey in skillNameMap) {
            const skillFullName = skillNameMap[skillKey];
            const arrow = (currentlyExpandedSkill === skillKey && document.getElementById(`expanded-skill-${skillKey}`)?.style.display !== 'none') ? '▼' : '►';
            skillsTableHTML += `<th class="clickable-skill-header" data-skill-key="${skillKey}" onclick="toggleSkillExpansion('${skillKey}')">${skillFullName} <span class="arrow-indicator">${arrow}</span></th>`;
        }
        skillsTableHTML += `</tr></thead><tbody>`;

        let pcsForSkillTable = [...selectedPcs]; 
        if (skillSortKey) {
            pcsForSkillTable.sort((a, b) => {
                const pcLevelA = a.flags?.ddbimporter?.dndbeyond?.totalLevels || a.system?.details?.level || 1;
                const profBonusA = getProficiencyBonus(pcLevelA);
                const skillDataA = a.vtt_data.skills?.[skillSortKey];
                const abilityKeyA = skillDataA?.ability || (skillSortKey === 'ath' ? 'str' : ['acr', 'slt', 'ste'].includes(skillSortKey) ? 'dex' : ['arc', 'his', 'inv', 'nat', 'rel'].includes(skillSortKey) ? 'int' : ['ani', 'ins', 'med', 'prc', 'sur'].includes(skillSortKey) ? 'wis' : 'cha');
                const abilityScoreA = a.vtt_data.abilities[abilityKeyA]?.value || 10;
                const bonusA = skillDataA ? calculateSkillBonus(abilityScoreA, skillDataA.value || 0, profBonusA) : getAbilityModifier(abilityScoreA);

                const pcLevelB = b.flags?.ddbimporter?.dndbeyond?.totalLevels || b.system?.details?.level || 1;
                const profBonusB = getProficiencyBonus(pcLevelB);
                const skillDataB = b.vtt_data.skills?.[skillSortKey];
                const abilityKeyB = skillDataB?.ability || (skillSortKey === 'ath' ? 'str' : ['acr', 'slt', 'ste'].includes(skillSortKey) ? 'dex' : ['arc', 'his', 'inv', 'nat', 'rel'].includes(skillSortKey) ? 'int' : ['ani', 'ins', 'med', 'prc', 'sur'].includes(skillSortKey) ? 'wis' : 'cha');
                const abilityScoreB = b.vtt_data.abilities[abilityKeyB]?.value || 10;
                const bonusB = skillDataB ? calculateSkillBonus(abilityScoreB, skillDataB.value || 0, profBonusB) : getAbilityModifier(abilityScoreB);
                
                return bonusB - bonusA; 
            });
        } else { 
             pcsForSkillTable.sort((a,b) => a.name.localeCompare(b.name));
        }


        pcsForSkillTable.forEach(pc => {
            const pcLevel = pc.flags?.ddbimporter?.dndbeyond?.totalLevels || pc.system?.details?.level || 1;
            const profBonus = getProficiencyBonus(pcLevel);
            skillsTableHTML += `<tr><td>${pc.name}</td>`;
            for (const skillKey in skillNameMap) {
                const skillData = pc.vtt_data.skills?.[skillKey];
                let skillBonusFormatted = "N/A";
                const defaultAbilityForSkill = (skillKey === 'ath' ? 'str' : ['acr', 'slt', 'ste'].includes(skillKey) ? 'dex' : ['arc', 'his', 'inv', 'nat', 'rel'].includes(skillKey) ? 'int' : ['ani', 'ins', 'med', 'prc', 'sur'].includes(skillKey) ? 'wis' : 'cha');
                const abilityKeyForSkill = skillData?.ability || defaultAbilityForSkill;

                if (pc.vtt_data.abilities[abilityKeyForSkill]) {
                    const abilityScore = pc.vtt_data.abilities[abilityKeyForSkill]?.value || 10;
                    const bonus = calculateSkillBonus(abilityScore, skillData?.value || 0, profBonus);
                    skillBonusFormatted = `${bonus >= 0 ? '+' : ''}${bonus}`;
                }
                skillsTableHTML += `<td>${skillBonusFormatted}</td>`;
            }
            skillsTableHTML += `</tr>`;
        });
        skillsTableHTML += `</tbody></table>`;
        const skillExpansionContainer = document.createElement('div');
        skillExpansionContainer.id = 'expanded-skill-details-sections';
        dashboardContent.innerHTML += skillsTableHTML;
        dashboardContent.appendChild(skillExpansionContainer);

        for (const skillKey in skillNameMap) {
            const expansionDiv = document.createElement('div');
            expansionDiv.id = `expanded-skill-${skillKey}`;
            expansionDiv.className = 'expanded-skill-content'; 
            expansionDiv.style.display = (currentlyExpandedSkill === skillKey) ? 'block' : 'none';
            if (currentlyExpandedSkill === skillKey && selectedPcs.length > 0) { 
                populateExpandedSkillDetails(skillKey, expansionDiv, selectedPcs);
            }
            skillExpansionContainer.appendChild(expansionDiv);
        }
    }

    function toggleAbilityExpansion(ablKey) {
        const selectedPcs = allCharacters.filter(char => activePcIds.has(char._id) && char.character_type === 'PC' && char.vtt_data);
        const expansionDiv = document.getElementById(`expanded-${ablKey}`);
        const headerTH = document.querySelector(`#main-stats-table th[data-ability="${ablKey}"]`);
        const arrowSpan = headerTH ? headerTH.querySelector('span.arrow-indicator') : null;

        if (!expansionDiv || !headerTH || !arrowSpan) return;
        const isCurrentlyHidden = expansionDiv.style.display === 'none';

        if (isCurrentlyHidden) { 
            if (selectedPcs.length === 0) { arrowSpan.textContent = ' ►'; return; }
            if (currentlyExpandedAbility && currentlyExpandedAbility !== ablKey) {
                const otherDiv = document.getElementById(`expanded-${currentlyExpandedAbility}`);
                const otherHeaderTH = document.querySelector(`#main-stats-table th[data-ability="${currentlyExpandedAbility}"]`);
                if (otherDiv) otherDiv.style.display = 'none';
                if (otherHeaderTH) otherHeaderTH.querySelector('span.arrow-indicator').textContent = ' ►';
            }
            populateExpandedAbilityDetails(ablKey.toUpperCase(), expansionDiv, selectedPcs);
            expansionDiv.style.display = 'block';
            arrowSpan.textContent = ' ▼';
            currentlyExpandedAbility = ablKey.toUpperCase();
        } else { 
            expansionDiv.style.display = 'none';
            arrowSpan.textContent = ' ►';
            currentlyExpandedAbility = null;
        }
    }
    
    function toggleSkillExpansion(skillKey) {
        if (currentlyExpandedSkill === skillKey) {
            skillSortKey = null; 
            currentlyExpandedSkill = null; 
        } else {
            skillSortKey = skillKey; 
            currentlyExpandedSkill = skillKey; 
        }
        updatePcDashboard(); 

        const allSkillHeaders = document.querySelectorAll(`#skills-overview-table th.clickable-skill-header`);
        allSkillHeaders.forEach(header => {
            const sKey = header.dataset.skillKey;
            const arrow = header.querySelector('span.arrow-indicator');
            const expDiv = document.getElementById(`expanded-skill-${sKey}`);
            if (expDiv) { 
                if (sKey === currentlyExpandedSkill) { 
                    if (arrow) arrow.textContent = ' ▼';
                    populateExpandedSkillDetails(sKey, expDiv, allCharacters.filter(char => activePcIds.has(char._id) && char.character_type === 'PC' && char.vtt_data));
                    expDiv.style.display = 'block';
                } else { 
                    if (arrow) arrow.textContent = ' ►';
                    expDiv.style.display = 'none';
                }
            }
        });
    }

    function populateExpandedSkillDetails(skillKey, expansionDiv, selectedPcs) {
        const skillNameMap = {
            "acr": "Acrobatics", "ani": "Animal Handling", "arc": "Arcana", "ath": "Athletics", 
            "dec": "Deception", "his": "History", "ins": "Insight", "itm": "Intimidation", 
            "inv": "Investigation", "med": "Medicine", "nat": "Nature", "prc": "Perception", 
            "prf": "Performance", "per": "Persuasion", "rel": "Religion", "slt": "Sleight of Hand", 
            "ste": "Stealth", "sur": "Survival"
        };
        const skillFullName = skillNameMap[skillKey] || skillKey.toUpperCase();
        let contentHTML = `<h5>${skillFullName} Skill Modifiers & Rules</h5>`;

        contentHTML += `<div class="skill-bar-chart-container">`;
        const skillDataForGraph = selectedPcs.map(pc => {
            const pcLevel = pc.flags?.ddbimporter?.dndbeyond?.totalLevels || pc.system?.details?.level || 1;
            const profBonus = getProficiencyBonus(pcLevel);
            const skillVttData = pc.vtt_data.skills?.[skillKey];
            const defaultAbilityForSkill = (skillKey === 'ath' ? 'str' : ['acr', 'slt', 'ste'].includes(skillKey) ? 'dex' : ['arc', 'his', 'inv', 'nat', 'rel'].includes(skillKey) ? 'int' : ['ani', 'ins', 'med', 'prc', 'sur'].includes(skillKey) ? 'wis' : 'cha');
            const baseAbilityKey = skillVttData?.ability || defaultAbilityForSkill;
            const baseAbilityScore = pc.vtt_data.abilities[baseAbilityKey]?.value || 10;
            const bonus = calculateSkillBonus(baseAbilityScore, skillVttData?.value || 0, profBonus);
            return { name: pc.name, modifier: bonus };
        }).sort((a,b) => b.modifier - a.modifier); 

        const allModifiers = skillDataForGraph.map(d => d.modifier);
        const dataMinMod = Math.min(0, ...allModifiers); 
        const dataMaxMod = Math.max(0, ...allModifiers); 

        const visualMin = Math.min(-2, dataMinMod -1); 
        const visualMax = Math.max(5, dataMaxMod + 1);   
        const visualRange = visualMax - visualMin;
        
        const zeroPositionPercent = visualRange !== 0 ? ((0 - visualMin) / visualRange) * 100 : 50; 

        skillDataForGraph.forEach(data => {
            let barWidthPercent = 0;
            let barLeftPercent = zeroPositionPercent;
            let barClass = 'stat-bar';

            if (visualRange !== 0) {
                if (data.modifier >= 0) {
                    barClass += ' positive';
                    barWidthPercent = (data.modifier / visualRange) * 100;
                } else { 
                    barClass += ' negative';
                    barWidthPercent = (Math.abs(data.modifier) / visualRange) * 100;
                    barLeftPercent = zeroPositionPercent - barWidthPercent; 
                }
            } else { 
                 barWidthPercent = data.modifier === 0 ? 0 : 50; 
                 if(data.modifier < 0) barLeftPercent = 0;
            }
            barWidthPercent = Math.max(0.5, barWidthPercent); 

            contentHTML += `<div class="pc-bar-row"> 
                                <div class="stat-comparison-pc-name" title="${data.name}">${data.name.substring(0,15)+(data.name.length > 15 ? '...' : '')}</div>
                                <div class="stat-bar-wrapper" style="--zero-offset: ${zeroPositionPercent}%;">
                                    <div class="${barClass}" style="left: ${barLeftPercent}%; width: ${barWidthPercent}%;">
                                        ${data.modifier >= 0 ? '+' : ''}${data.modifier}
                                    </div>
                                </div>
                           </div>`;
        });
        contentHTML += `</div>`;


        // Rule Text
        contentHTML += `<table class="rules-explanation-table"><tr><td>`;
        switch (skillKey) {
            case 'acr': contentHTML += "Your Dexterity (Acrobatics) check covers your attempt to stay on your feet in a tricky situation, such as when you’re trying to run across a sheet of ice, balance on a tightrope, or stay upright on a rocking ship’s deck. The GM might also call for a Dexterity (Acrobatics) check to see if you can perform acrobatic stunts, including dives, rolls, somersaults, and flips."; break;
            case 'ath': contentHTML += "Your Strength (Athletics) check covers difficult situations you encounter while climbing, jumping, or swimming. Examples include: attempting to climb a sheer or slippery cliff, trying to jump an unusually long distance, or struggling to swim in treacherous currents."; break;
            case 'slt': contentHTML += "Whenever you attempt an act of legerdemain or manual trickery, such as planting something on someone else or concealing an object on your person, make a Dexterity (Sleight of Hand) check. The GM might also call for a Dexterity (Sleight of Hand) check to determine whether you can lift a coin purse off another person or slip something out of another person’s pocket."; break;
            case 'ste': contentHTML += "Make a Dexterity (Stealth) check when you attempt to conceal yourself from enemies, slink past guards, slip away without being noticed, or sneak up on someone without being seen or heard."; break;
            case 'arc': contentHTML += "Your Intelligence (Arcana) check measures your ability to recall lore about spells, magic items, eldritch symbols, magical traditions, the planes of existence, and the inhabitants of those planes."; break;
            case 'his': contentHTML += "Your Intelligence (History) check measures your ability to recall lore about historical events, legendary people, ancient kingdoms, past disputes, recent wars, and lost civilizations."; break;
            case 'inv': contentHTML += "When you look around for clues and make deductions based on those clues, you make an Intelligence (Investigation) check. You might deduce the location of a hidden object, discern from the appearance of a wound what kind of weapon dealt it, or determine the weakest point in a tunnel that could cause it to collapse."; break;
            case 'nat': contentHTML += "Your Intelligence (Nature) check measures your ability to recall lore about terrain, plants and animals, the weather, and natural cycles."; break;
            case 'rel': contentHTML += "Your Intelligence (Religion) check measures your ability to recall lore about deities, rites and prayers, religious hierarchies, holy symbols, and the practices of secret cults."; break;
            case 'ani': contentHTML += "When there is any question whether you can calm down a domesticated animal, keep a mount from getting spooked, or intuit an animal’s intentions, the GM might call for a Wisdom (Animal Handling) check. You also make a Wisdom (Animal Handling) check to control your mount when you attempt a risky maneuver."; break;
            case 'ins': contentHTML += "Your Wisdom (Insight) check decides whether you can determine the true intentions of a creature, such as when searching out a lie or predicting someone’s next move. Doing so involves gleaning clues from body language, speech habits, and changes in mannerisms."; break;
            case 'med': contentHTML += "A Wisdom (Medicine) check lets you try to stabilize a dying companion or diagnose an illness."; break;
            case 'prc': contentHTML += "Your Wisdom (Perception) check lets you spot, hear, or otherwise detect the presence of something. It measures your general awareness of your surroundings and the keenness of your senses."; break;
            case 'sur': contentHTML += "The GM might ask you to make a Wisdom (Survival) check to follow tracks, hunt wild game, guide your group through frozen wastelands, identify signs that owlbears live nearby, predict the weather, or avoid quicksand and other natural hazards."; break;
            case 'dec': contentHTML += "Your Charisma (Deception) check determines whether you can convincingly hide the truth, either verbally or through your actions. This deception can encompass everything from misleading others through ambiguity to telling outright lies."; break;
            case 'itm': contentHTML += "When you attempt to influence someone through overt threats, hostile actions, and physical violence, the GM might ask you to make a Charisma (Intimidation) check."; break;
            case 'prf': contentHTML += "Your Charisma (Performance) check determines how well you can delight an audience with music, dance, acting, storytelling, or some other form of entertainment."; break;
            case 'per': contentHTML += "When you attempt to influence someone or a group of people with tact, social graces, or good nature, the GM might ask you to make a Charisma (Persuasion) check."; break;
            default: contentHTML += `General information about the ${skillFullName} skill. (Details to be added).`; break;
        }
        contentHTML += "</td></tr></table>";
        expansionDiv.innerHTML = contentHTML;
    }


    function populateExpandedAbilityDetails(ablKey, expansionDiv, selectedPcsInput) {
        const upperAblKey = ablKey.toUpperCase();
        const lowerAblKey = ablKey.toLowerCase();

        const sortedPcs = [...selectedPcsInput].sort((a, b) => {
            const scoreA = a.vtt_data.abilities[lowerAblKey]?.value || 0;
            const scoreB = b.vtt_data.abilities[lowerAblKey]?.value || 0;
            return scoreB - scoreA;
        });

        let contentHTML = `<h5>${upperAblKey} Score Comparison</h5>`;
        contentHTML += `<div class="ability-bar-chart-container">`;
        sortedPcs.forEach(pc => {
            const score = pc.vtt_data.abilities[lowerAblKey]?.value || 0;
            const barWidth = Math.max(5, (score / 20) * 100); 
            contentHTML += `<div class="pc-bar-row"> 
                                <div class="stat-comparison-pc-name" title="${pc.name}">${pc.name.substring(0,15)+(pc.name.length > 15 ? '...' : '')}</div>
                                <div class="stat-bar-wrapper"><div class="stat-bar" style="width: ${barWidth}%;">${score}</div></div>
                           </div>`;
        });
        contentHTML += `</div>`;
        
        contentHTML += `<h5>${upperAblKey} Derived Stats Summary</h5><table class="derived-stats-table"><thead><tr><th>Derived Stat</th>`;
        sortedPcs.forEach(pc => { contentHTML += `<th>${pc.name.substring(0,10)+(pc.name.length > 10 ? '...' : '')}</th>`; });
        contentHTML += `</tr></thead><tbody>`;

        let generalDerivedMetrics = ["Modifier", `${upperAblKey} Save`];
        if (upperAblKey === 'STR') generalDerivedMetrics.push("Long Jump (Run/Stand)", "High Jump (Run/Stand)");
        else if (upperAblKey === 'DEX') generalDerivedMetrics.push("Initiative");
        else if (upperAblKey === 'CON') generalDerivedMetrics.push("Hold Breath");
        else if (upperAblKey === 'WIS') generalDerivedMetrics.push("Passive Perception (Calc)");

        sortedPcs.forEach(pc => {
            const pcLevel = pc.flags?.ddbimporter?.dndbeyond?.totalLevels || pc.system?.details?.level || 1;
            pc.calculatedProfBonus = getProficiencyBonus(pcLevel);
        });

        generalDerivedMetrics.forEach(metricName => {
            contentHTML += `<tr><th>${metricName}</th>`;
            sortedPcs.forEach(pc => {
                const score = pc.vtt_data.abilities[lowerAblKey]?.value || 0;
                const modifier = getAbilityModifier(score);
                const isSaveProficient = pc.vtt_data.abilities[lowerAblKey]?.proficient === 1;
                let value = 'N/A';

                if (metricName === "Modifier") value = `${modifier >= 0 ? '+' : ''}${modifier}`;
                else if (metricName === `${upperAblKey} Save`) {
                    const saveBonus = savingThrowBonus(score, isSaveProficient, pc.calculatedProfBonus);
                    value = `${saveBonus >= 0 ? '+' : ''}${saveBonus} ${isSaveProficient ? '<abbr title="Proficient">(P)</abbr>' : ''}`;
                }
                else if (metricName === "Long Jump (Run/Stand)" && upperAblKey === 'STR') value = `${longJump(score, true)}ft / ${longJump(score, false)}ft`;
                else if (metricName === "High Jump (Run/Stand)" && upperAblKey === 'STR') value = `${highJump(score, true)}ft / ${highJump(score, false)}ft`;
                else if (metricName === "Initiative" && upperAblKey === 'DEX') value = `${initiative(score) >= 0 ? '+' : ''}${initiative(score)}`;
                else if (metricName === "Hold Breath" && upperAblKey === 'CON') value = `${holdBreath(score)}`;
                else if (metricName === "Passive Perception (Calc)" && upperAblKey === 'WIS') {
                    const wisScoreVal = pc.vtt_data.abilities.wis?.value || 0;
                    const percSkillInfo = pc.vtt_data.skills?.prc;
                    value = calculatePassiveSkill(wisScoreVal, percSkillInfo?.value || 0, pc.calculatedProfBonus);
                }
                contentHTML += `<td>${value}</td>`;
            });
            contentHTML += `</tr>`;
        });
        contentHTML += `</tbody></table>`;

        contentHTML += `<hr><h4>${upperAblKey} Applications & Calculations</h4>`;

        if (upperAblKey === 'STR') {
            contentHTML += `<h5>Strength Checks & Athletics</h5><table class="rules-explanation-table"><tr><td><strong>General:</strong> Strength checks model any attempt to lift, push, pull, or break something, to force your body through a space, or to otherwise apply brute force to a situation. The Athletics skill reflects aptitude in certain kinds of Strength checks.</td></tr><tr><td><strong>Athletics Examples:</strong><ul><li>Attempt to climb a sheer or slippery cliff, avoid hazards while scaling a wall, or cling to a surface while something is trying to knock you off.</li><li>Try to jump an unusually long distance or pull off a stunt midjump.</li><li>Struggle to swim or stay afloat in treacherous currents, storm-tossed waves, or areas of thick seaweed. Or another creature tries to push or pull you underwater or otherwise interfere with your swimming.</li></ul></td></tr><tr><td><strong>Other Strength Check Examples:</strong><ul><li>Force open a stuck, locked, or barred door.</li><li>Break free of bonds.</li><li>Push through a tunnel that is too small.</li><li>Hang on to a wagon while being dragged behind it.</li><li>Tip over a statue.</li><li>Keep a boulder from rolling.</li></ul></td></tr></table>`;
            contentHTML += `<h5>Attack Rolls and Damage (Melee Weapons)</h5><table class="rules-explanation-table"><tr><td>You add your Strength modifier to your attack roll and your damage roll when attacking with a melee weapon such as a mace, a battleaxe, or a javelin. You use melee weapons to make melee attacks in hand-to-hand combat, and some of them can be thrown to make a ranged attack.</td></tr></table>`;
            contentHTML += `<table class="derived-stats-table"><thead><tr><th>Character</th><th>STR Modifier (for Melee Attack/Damage)</th></tr></thead><tbody>`;
            sortedPcs.forEach(pc => {
                const score = pc.vtt_data.abilities.str?.value || 0; const mod = getAbilityModifier(score);
                contentHTML += `<tr><td>${pc.name}</td><td>${mod >= 0 ? '+' : ''}${mod}</td></tr>`;
            });
            contentHTML += `</tbody></table>`;
            contentHTML += `<h5>Lifting and Carrying</h5><table class="rules-explanation-table"><tr><td><strong>Carrying Capacity Rule:</strong> Your carrying capacity is your Strength score multiplied by 15. This is the weight (in pounds) that you can carry.</td></tr><tr><td><strong>Push, Drag, or Lift Rule:</strong> You can push, drag, or lift a weight in pounds up to twice your carrying capacity (or 30 times your Strength score). While pushing or dragging weight in excess of your carrying capacity, your speed drops to 5 feet.</td></tr><tr><td><strong>Size and Strength Rule:</strong> Larger creatures can bear more weight, whereas Tiny creatures can carry less. For each size category above Medium, double the creature’s carrying capacity and the amount it can push, drag, or lift. For a Tiny creature, halve these weights. (Calculations below account for this).</td></tr></table>`;
            contentHTML += `<table class="derived-stats-table"><thead><tr><th>Character</th><th>Size</th><th>Carrying Capacity (lbs)</th><th>Push/Drag/Lift (lbs)</th></tr></thead><tbody>`;
            sortedPcs.forEach(pc => {
                const score = pc.vtt_data.abilities.str?.value || 0; const size = pc.system?.traits?.size || 'med';
                let capMultiplier = 1; if (size === 'tiny') capMultiplier = 0.5; else if (size === 'lg') capMultiplier = 2; else if (size === 'huge') capMultiplier = 4; else if (size === 'grg') capMultiplier = 8;
                const baseCap = carryingCapacity(score); const actualCap = Math.floor(baseCap * capMultiplier); const pdl = actualCap * 2;
                const sizeMap = { 'tiny': 'Tiny', 'sm': 'Small', 'med': 'Medium', 'lg': 'Large', 'huge': 'Huge', 'grg': 'Gargantuan' };
                contentHTML += `<tr><td>${pc.name}</td><td>${sizeMap[size] || size}</td><td>${actualCap}</td><td>${pdl}</td></tr>`;
            });
            contentHTML += `</tbody></table>`;
            contentHTML += `<h5>Variant: Encumbrance</h5><table class="rules-explanation-table"><tr><td>(When you use this variant, ignore the Strength column of the Armor table.)</td></tr><tr><td><strong>Encumbered:</strong> If you carry weight in excess of 5 times your Strength score, you are encumbered, which means your speed drops by 10 feet.</td></tr><tr><td><strong>Heavily Encumbered:</strong> If you carry weight in excess of 10 times your Strength score, up to your maximum carrying capacity, you are instead heavily encumbered, which means your speed drops by 20 feet and you have disadvantage on ability checks, attack rolls, and saving throws that use Strength, Dexterity, or Constitution.</td></tr></table>`;
            contentHTML += `<table class="derived-stats-table"><thead><tr><th>Character</th><th>Encumbered At (> lbs)</th><th>Heavily Encumbered At (> lbs)</th></tr></thead><tbody>`;
            sortedPcs.forEach(pc => {
                const score = pc.vtt_data.abilities.str?.value || 0;
                contentHTML += `<tr><td>${pc.name}</td><td>${score * 5}</td><td>${score * 10}</td></tr>`;
            });
            contentHTML += `</tbody></table>`;
        } 
        else if (upperAblKey === 'DEX') {
            contentHTML += `<h5>Dexterity Checks</h5><table class="rules-explanation-table"><tr><td>A Dexterity check can model any attempt to move nimbly, quickly, or quietly, or to keep from falling on tricky footing. The Acrobatics, Sleight of Hand, and Stealth skills reflect aptitude in certain kinds of Dexterity checks.</td></tr></table>`;
            contentHTML += `<h5>Attack Rolls and Damage (Ranged/Finesse)</h5><table class="rules-explanation-table"><tr><td>You add your Dexterity modifier to your attack roll and your damage roll when attacking with a ranged weapon, such as a sling or a longbow. You can also add your Dexterity modifier to your attack roll and your damage roll when attacking with a melee weapon that has the finesse property, such as a dagger or a rapier.</td></tr></table>`;
            contentHTML += `<table class="derived-stats-table"><thead><tr><th>Character</th><th>DEX Modifier (for Ranged/Finesse Attack/Damage)</th></tr></thead><tbody>`;
            sortedPcs.forEach(pc => {
                const score = pc.vtt_data.abilities.dex?.value || 0; const mod = getAbilityModifier(score);
                contentHTML += `<tr><td>${pc.name}</td><td>${mod >= 0 ? '+' : ''}${mod}</td></tr>`;
            });
            contentHTML += `</tbody></table>`;
            contentHTML += `<h5>Armor Class</h5><table class="rules-explanation-table"><tr><td>Depending on the armor you wear, you might add some or all of your Dexterity modifier to your Armor Class. (Actual AC is on individual character cards).</td></tr></table>`;
            contentHTML += `<h5>Initiative</h5><table class="rules-explanation-table"><tr><td>At the beginning of every combat, you roll initiative by making a Dexterity check. Initiative determines the order of creatures’ turns in combat.</td></tr></table>`;
            contentHTML += `<h5>Hiding</h5><table class="rules-explanation-table"><tr><td>Make a Dexterity (Stealth) check. Contested by Wisdom (Perception) of searchers...<br><strong>Passive Perception:</strong> Your Dexterity (Stealth) check is compared against a creature's passive Wisdom (Perception) score (10 + creature's Wisdom modifier + bonuses/penalties).</td></tr></table>`;
        }
        else if (upperAblKey === 'CON') {
            contentHTML += `<h5>Constitution Checks</h5><table class="rules-explanation-table"><tr><td>Constitution checks are uncommon, and no skills apply to Constitution checks, because the endurance this ability represents is largely passive... Examples: Hold your breath, march or labor for hours without rest, go without sleep, survive without food or water, quaff an entire stein of ale in one go.</td></tr></table>`;
            contentHTML += `<h5>Hit Points</h5><table class="rules-explanation-table"><tr><td>Your Constitution modifier contributes to your hit points. Typically, you add your Constitution modifier to each Hit Die you roll for your hit points. If your Constitution modifier changes, your hit point maximum changes as well, as though you had the new modifier from 1st level.</td></tr></table>`;
            contentHTML += `<table class="derived-stats-table"><thead><tr><th>Character</th><th>CON Modifier (for HP)</th><th>Max HP (from VTT)</th></tr></thead><tbody>`;
            sortedPcs.forEach(pc => {
                const score = pc.vtt_data.abilities.con?.value || 0; const mod = getAbilityModifier(score);
                const hpMax = pc.vtt_data.attributes.hp?.max !== undefined && pc.vtt_data.attributes.hp.max !== null ? pc.vtt_data.attributes.hp.max : 'N/A';
                contentHTML += `<tr><td>${pc.name}</td><td>${mod >= 0 ? '+' : ''}${mod}</td><td>${hpMax}</td></tr>`;
            });
            contentHTML += `</tbody></table>`;
        }
        else if (upperAblKey === 'INT') {
            contentHTML += `<h5>Intelligence Checks</h5><table class="rules-explanation-table"><tr><td>An Intelligence check comes into play when you need to draw on logic, education, memory, or deductive reasoning. The Arcana, History, Investigation, Nature, and Religion skills reflect aptitude in certain kinds of Intelligence checks.</td></tr></table>`;
            contentHTML += `<h5>Other Intelligence Checks</h5><table class="rules-explanation-table"><tr><td>The GM might call for an Intelligence check when you try to accomplish tasks like: Communicate with a creature without using words, estimate the value of a precious item, pull together a disguise to pass as a city guard, forge a document, recall lore about a craft or trade, win a game of skill.</td></tr></table>`;
            contentHTML += `<h5>Spellcasting Ability (Wizards)</h5><table class="rules-explanation-table"><tr><td>Wizards use Intelligence as their spellcasting ability, which helps determine the saving throw DCs of spells they cast.</td></tr></table>`;
            if (sortedPcs.some(pc => pc.vtt_data.attributes?.spellcasting === 'int')) {
                contentHTML += `<table class="derived-stats-table"><thead><tr><th>Character (INT Casters)</th><th>Spell Save DC</th><th>Spell Attack Bonus</th></tr></thead><tbody>`;
                sortedPcs.filter(pc => pc.vtt_data.attributes?.spellcasting === 'int').forEach(pc => {
                    const score = pc.vtt_data.abilities.int?.value || 0;
                    contentHTML += `<tr><td>${pc.name}</td><td>${spellSaveDC(score, pc.calculatedProfBonus)}</td><td>+${spellAttackBonus(score, pc.calculatedProfBonus)}</td></tr>`;
                });
                contentHTML += `</tbody></table>`;
            }
        }
        else if (upperAblKey === 'WIS') {
            contentHTML += `<h5>Wisdom Checks</h5><table class="rules-explanation-table"><tr><td>A Wisdom check might reflect an effort to read body language, understand someone’s feelings, notice things about the environment, or care for an injured person. The Animal Handling, Insight, Medicine, Perception, and Survival skills reflect aptitude in certain kinds of Wisdom checks.</td></tr></table>`;
            contentHTML += `<h5>Other Wisdom Checks</h5><table class="rules-explanation-table"><tr><td>The GM might call for a Wisdom check when you try to accomplish tasks like: Get a gut feeling about what course of action to follow, discern whether a seemingly dead or living creature is undead.</td></tr></table>`;
            contentHTML += `<h5>Spellcasting Ability (Clerics, Druids, Rangers)</h5><table class="rules-explanation-table"><tr><td>Clerics, druids, and rangers use Wisdom as their spellcasting ability, which helps determine the saving throw DCs of spells they cast.</td></tr></table>`;
             if (sortedPcs.some(pc => pc.vtt_data.attributes?.spellcasting === 'wis')) {
                contentHTML += `<table class="derived-stats-table"><thead><tr><th>Character (WIS Casters)</th><th>Spell Save DC</th><th>Spell Attack Bonus</th></tr></thead><tbody>`;
                sortedPcs.filter(pc => pc.vtt_data.attributes?.spellcasting === 'wis').forEach(pc => {
                    const score = pc.vtt_data.abilities.wis?.value || 0;
                    contentHTML += `<tr><td>${pc.name}</td><td>${spellSaveDC(score, pc.calculatedProfBonus)}</td><td>+${spellAttackBonus(score, pc.calculatedProfBonus)}</td></tr>`;
                });
                contentHTML += `</tbody></table>`;
            }
        }
        else if (upperAblKey === 'CHA') {
            contentHTML += `<h5>Charisma Checks</h5><table class="rules-explanation-table"><tr><td>A Charisma check might arise when you try to influence or entertain others, when you try to make an impression or tell a convincing lie, or when you are navigating a tricky social situation. The Deception, Intimidation, Performance, and Persuasion skills reflect aptitude in certain kinds of Charisma checks.</td></tr></table>`;
            contentHTML += `<h5>Other Charisma Checks</h5><table class="rules-explanation-table"><tr><td>The GM might call for a Charisma check when you try to accomplish tasks like: Find the best person to talk to for news, rumors, and gossip, blend into a crowd to get the sense of key topics of conversation.</td></tr></table>`;
            contentHTML += `<h5>Spellcasting Ability (Bards, Paladins, Sorcerers, Warlocks)</h5><table class="rules-explanation-table"><tr><td>Bards, paladins, sorcerers, and warlocks use Charisma as their spellcasting ability, which helps determine the saving throw DCs of spells they cast.</td></tr></table>`;
            if (sortedPcs.some(pc => pc.vtt_data.attributes?.spellcasting === 'cha')) {
                contentHTML += `<table class="derived-stats-table"><thead><tr><th>Character (CHA Casters)</th><th>Spell Save DC</th><th>Spell Attack Bonus</th></tr></thead><tbody>`;
                sortedPcs.filter(pc => pc.vtt_data.attributes?.spellcasting === 'cha').forEach(pc => {
                    const score = pc.vtt_data.abilities.cha?.value || 0;
                    contentHTML += `<tr><td>${pc.name}</td><td>${spellSaveDC(score, pc.calculatedProfBonus)}</td><td>+${spellAttackBonus(score, pc.calculatedProfBonus)}</td></tr>`;
                });
                contentHTML += `</tbody></table>`;
            }
        }
        expansionDiv.innerHTML = contentHTML;
    }

    function createSkillTable(skillName, skillAbbr, ablKey, sortedPcs) {
        let tableHTML = `<table class="derived-stats-table"><thead><tr><th>Character</th><th>${skillName} Modifier</th></tr></thead><tbody>`;
        let foundSkill = false;
        sortedPcs.forEach(pc => {
            const skillData = pc.vtt_data.skills?.[skillAbbr];
            const abilityScore = pc.vtt_data.abilities?.[ablKey.toLowerCase()]?.value || 10; 
            let skillBonusFormatted = "N/A";

            if (skillData) { 
                 const skillBonusValue = calculateSkillBonus(abilityScore, skillData.value || 0, pc.calculatedProfBonus);
                 skillBonusFormatted = `${skillBonusValue >= 0 ? '+' : ''}${skillBonusValue}`;
                 foundSkill = true;
            } else { 
                const modifier = getAbilityModifier(abilityScore);
                skillBonusFormatted = `${modifier >= 0 ? '+' : ''}${modifier} (No Prof.)`;
            }
            tableHTML += `<tr><td>${pc.name}</td><td>${skillBonusFormatted}</td></tr>`;
        });
        tableHTML += `</tbody></table>`;
        return tableHTML; 
    }

    function createToolTable(toolName, toolAbbr, ablKey, sortedPcs, note = "") {
        let tableHTML = `<table class="derived-stats-table"><thead><tr><th>Character</th><th>${toolName} Bonus ${note}</th></tr></thead><tbody>`;
        let foundToolForAnyPC = false;
        sortedPcs.forEach(pc => {
            const toolData = pc.vtt_data.tools?.[toolAbbr];
            const baseAbilityScore = pc.vtt_data.abilities?.[(toolData?.ability || ablKey).toLowerCase()]?.value || 10;
            let toolBonusFormatted = "N/P"; 

            if (toolData && toolData.value === 1) { 
                const modifier = getAbilityModifier(baseAbilityScore);
                const toolBonusValue = modifier + pc.calculatedProfBonus;
                toolBonusFormatted = `${toolBonusValue >= 0 ? '+' : ''}${toolBonusValue}`;
                foundToolForAnyPC = true;
            } else if (toolData) { 
                 const modifier = getAbilityModifier(baseAbilityScore);
                 toolBonusFormatted = `${modifier >= 0 ? '+' : ''}${modifier} (Not Proficient)`;
                 foundToolForAnyPC = true; 
            }
            tableHTML += `<tr><td>${pc.name}</td><td>${toolBonusFormatted}</td></tr>`;
        });
        tableHTML += `</tbody></table>`;
         return foundToolForAnyPC || sortedPcs.length > 0 ? tableHTML : `<p><em>No ${toolName} proficiency data found for selected PCs.</em></p>`;
    }

    // --- UI Control Functions ---
    function setupInterfaceControls() {
        const resizer = getElem('resizer');
        const leftColumn = getElem('left-column');
        if (resizer && leftColumn) {
            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                document.body.style.cursor = 'col-resize'; 
                leftColumn.style.userSelect = 'none'; 
                const startX = e.clientX;
                const startWidth = leftColumn.offsetWidth;
                
                const handleMouseMove = (moveEvent) => {
                    let newWidth = startWidth + (moveEvent.clientX - startX);
                    const computedStyle = getComputedStyle(leftColumn);
                    const minPxWidth = parseFloat(computedStyle.minWidth);
                    const maxPxWidthStyle = computedStyle.maxWidth;
                    let maxPxWidth = Infinity;

                    if (maxPxWidthStyle.includes('%')) {
                        const parentWidth = leftColumn.parentElement.offsetWidth; 
                        maxPxWidth = (parseFloat(maxPxWidthStyle) / 100) * parentWidth;
                    } else if (maxPxWidthStyle && maxPxWidthStyle !== 'none' && !maxPxWidthStyle.includes('%')) {
                        maxPxWidth = parseFloat(maxPxWidthStyle);
                    }
                    
                    if (newWidth < minPxWidth) newWidth = minPxWidth;
                    if (newWidth > maxPxWidth) newWidth = maxPxWidth;
                    
                    leftColumn.style.width = `${newWidth}px`;
                };
                const handleMouseUp = () => {
                    document.body.style.cursor = 'default';
                    leftColumn.style.userSelect = 'auto';
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
            });
        } else {
            console.error("Resizer or leftColumn element not found. Resizing will not work.");
        }

        document.querySelectorAll('.collapsible-section h3').forEach(header => {
            header.addEventListener('click', () => {
                const section = header.parentElement;
                section.classList.toggle('collapsed');
                const arrowIndicator = header.childNodes[header.childNodes.length -1]; 
                if(arrowIndicator && arrowIndicator.nodeType === Node.TEXT_NODE) {
                    arrowIndicator.textContent = section.classList.contains('collapsed') ? ' ►' : ' ▼';
                }
            });
        });
    }
    
    // --- Window Onload ---
    window.onload = () => {
        fetchCharacters(); 
        setupInterfaceControls();
    };

    // --- Full Functions for CRUD and Dialogue ---
    async function createCharacter() {
        const name = getElem('new-char-name').value;
        const description = getElem('new-char-description').value;
        const personality = getElem('new-char-personality').value.split(',').map(s => s.trim()).filter(s => s);
        const characterType = getElem('new-char-type').value;
        if (!name || !description) { alert('Character Name and Description are required.'); return; }
        try {
            const response = await fetch(`${API_BASE_URL}/api/npcs`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    name, 
                    description, 
                    character_type: characterType, 
                    personality_traits: personality, 
                    memories: [], 
                    gm_notes: "",
                    associated_history_files: [] // Initialize with empty list
                })
            });
            if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || `HTTP error! status: ${response.status}`);}
            const result = await response.json();
            alert(result.message);
            fetchCharacters(); 
            getElem('new-char-name').value = ''; getElem('new-char-description').value = ''; getElem('new-char-personality').value = ''; getElem('new-char-type').value = 'NPC';
        } catch (error) { console.error('Error creating character:', error); alert(`Failed to create character: ${error.message}`);}
    }

    async function saveGMNotes() {
        if (!currentProfileCharId) { alert('No character selected in profile to save notes for.'); return; }
        
        const notes = getElem('gm-notes').value;
        try {
            const response = await fetch(`${API_BASE_URL}/api/npcs/${currentProfileCharId}`, { 
                method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ gm_notes: notes })
            });
            if (!response.ok) throw new Error('Failed to save notes');
            const result = await response.json(); alert(result.message);
            const charIndex = allCharacters.findIndex(char => char._id === currentProfileCharId);
            if (charIndex > -1) allCharacters[charIndex].gm_notes = notes;
        } catch (error) { console.error('Error saving GM notes:', error); alert('Failed to save GM notes.');}
    }

    function renderMemories(memories) {
        const listDiv = getElem('character-memories-list');
        listDiv.innerHTML = '<h4>Current Memories:</h4>'; 
        if (!memories || memories.length === 0) { listDiv.innerHTML += '<p>No memories yet.</p>'; return; }
        const ul = document.createElement('ul');
        memories.forEach(mem => {
            const itemDiv = document.createElement('li'); 
            itemDiv.className = 'memory-item';
            const timestamp = mem.timestamp ? (mem.timestamp.$date ? new Date(mem.timestamp.$date).toLocaleTimeString() : new Date(mem.timestamp).toLocaleTimeString()) : 'N/A';
            itemDiv.innerHTML = `<span>(${timestamp}) [${mem.type || 'generic'}] ${mem.content}</span><button onclick="deleteMemory('${mem.memory_id}')">Undo</button>`;
            ul.appendChild(itemDiv);
        });
        listDiv.appendChild(ul);
    }

    async function addMemoryToCharacter(content = null, type = null) {
        if (!currentProfileCharId) { alert("View a character's details in the Profile section to add a memory to them."); return; }
        const characterForMemory = allCharacters.find(c => c._id === currentProfileCharId);
        if (!characterForMemory || characterForMemory.character_type !== 'NPC') {
            alert("Memories can only be added to NPCs currently viewed in the profile.");
            return;
        }

        const memoryContent = content || getElem('new-memory-content').value;
        const memoryType = type || getElem('new-memory-type').value || 'manual_fact';
        if (!memoryContent) { alert('Memory content cannot be empty.'); return; }
        try {
            const response = await fetch(`${API_BASE_URL}/api/npcs/${currentProfileCharId}/memory`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ content: memoryContent, type: memoryType, source: 'gm_interface_manual' })
            });
            const result = await response.json();
            if (!response.ok) throw new Error(result.error || `Failed to add memory.`);
            alert(result.message || 'Memory added!');
            const charIndex = allCharacters.findIndex(char => char._id === currentProfileCharId);
            if (charIndex > -1) {
                if (!allCharacters[charIndex].memories) allCharacters[charIndex].memories = [];
                allCharacters[charIndex].memories = result.updated_memories; 
                renderMemories(allCharacters[charIndex].memories); 
            }
            if (!content) getElem('new-memory-content').value = ''; 
            if (!type) getElem('new-memory-type').value = '';
            getElem('suggested-memories-list').innerHTML = '<strong>Suggested Memories (click to add):</strong><p>None.</p>';
            getElem('suggested-topics-list').innerHTML = '<strong>Suggested Topics (click to use as player utterance):</strong><p>None.</p>';
        } catch (error) { console.error('Error adding memory:', error); alert(`Failed to add memory: ${error.message}`);}
    }

    async function deleteMemory(memoryId) {
        if (!currentProfileCharId) { alert("View an NPC's details in the Profile section to delete a memory."); return; }
        const characterForMemory = allCharacters.find(c => c._id === currentProfileCharId);
        if (!characterForMemory || characterForMemory.character_type !== 'NPC') {
            alert("Memories can only be deleted from NPCs currently viewed in the profile.");
            return;
        }
        if (!memoryId) return;
        if (!confirm('Are you sure you want to delete this memory?')) return;
        try {
            const response = await fetch(`${API_BASE_URL}/api/npcs/${currentProfileCharId}/memory/${memoryId}`, { method: 'DELETE' });
            const result = await response.json();
            if (!response.ok) throw new Error(result.error || `Failed to delete memory.`);
            alert(result.message || 'Memory deleted!');
            const charIndex = allCharacters.findIndex(char => char._id === currentProfileCharId);
            if (charIndex > -1) { 
                allCharacters[charIndex].memories = result.updated_memories; 
                renderMemories(allCharacters[charIndex].memories);
            }
        } catch (error) { console.error('Error deleting memory:', error); alert(`Failed to delete memory: ${error.message}`);}
    }

    async function generateDialogue() {
        if (activeSceneNpcIds.size === 0) { alert('Please add NPCs to the scene first.'); return; }
        const sceneContext = getElem('scene-context').value;
        const playerUtterance = getElem('player-utterance').value;
        const activePCsInfo = Array.from(activePcIds).map(id => { 
            const pc = allCharacters.find(char => char._id === id); 
            return pc ? { id: pc._id, name: pc.name } : null;
        }).filter(pc => pc !== null);

        if (!sceneContext && playerUtterance.trim() === "") { alert('Scene context or player utterance is required.'); return; }
        
        dialogueHistory.push({ type: 'player', speakerName: 'Player', id: null, utterance: playerUtterance });
        activeSceneNpcIds.forEach(npcId => {
            addDialogueToTranscript(playerUtterance, 'player', 'Player', npcId); 
            if(!dialogueHistories[npcId]) dialogueHistories[npcId] = [];
            dialogueHistories[npcId].push({ type: 'player', speakerName: 'Player', id: null, utterance: playerUtterance });
        });
        
        disableBtn('generate-dialogue-btn', true);
        const promises = [];

        activeSceneNpcIds.forEach(currentNpcId => {
            const currentNpc = allCharacters.find(c => c._id === currentNpcId);
            if (!currentNpc) {
                console.error(`Could not find NPC with ID ${currentNpcId} in allCharacters array.`);
                return; // Skip this NPC if not found
            }
// ...

            const payload = { 
                scene_context: sceneContext, 
                player_utterance: playerUtterance, 
                active_pcs: activePCsInfo.map(pc => pc.name), 
                // Use NPC-specific recent history if available, otherwise global
                recent_dialogue_history: (dialogueHistories[currentNpcId] && dialogueHistories[currentNpcId].length > 0) ?
                                         dialogueHistories[currentNpcId].slice(-10).map(d => `${d.speakerName}: ${d.utterance}`) :
                                         dialogueHistory.slice(-10).map(d => `${d.speakerName}: ${d.utterance}`),
                other_active_npcs_dialogue: otherActiveNpcsDialogueSummary,
                // --- THIS IS THE CRUCIAL LINE FOR NPC HISTORY ---
                npc_history: currentNpc.combined_history_content || "" 
                // --- Make sure currentNpc object has 'combined_history_content' populated ---
            };
            
            // For debugging the payload being sent from frontend:
            console.log(`Payload for ${currentNpc.name} (ID: ${currentNpcId}):`, JSON.parse(JSON.stringify(payload)));


            const otherActiveNpcsDialogueSummary = [];
            activeSceneNpcIds.forEach(otherNpcId => {
                if (otherNpcId !== currentNpcId) {
                    const otherNpc = allCharacters.find(c => c._id === otherNpcId);
                    if (otherNpc) {
                        let lastUtterance = "";
                        const historyForOtherNpc = dialogueHistories[otherNpcId] || [];
                        for (let i = historyForOtherNpc.length - 1; i >= 0; i--) {
                            if (historyForOtherNpc[i].id === otherNpcId) { 
                                lastUtterance = historyForOtherNpc[i].utterance;
                                break;
                            }
                        }
                         if (!lastUtterance) { 
                            for (let i = dialogueHistory.length - 1; i >= 0; i--) {
                                if (dialogueHistory[i].id === otherNpcId) {
                                    lastUtterance = dialogueHistory[i].utterance;
                                    break;
                                }
                            }
                        }
                        otherActiveNpcsDialogueSummary.push({
                            npc_id: otherNpc._id,
                            npc_name: otherNpc.name,
                            last_utterance: lastUtterance
                        });
                    }
                }
            });

            const npcSpecificRecentHistory = dialogueHistories[currentNpcId] ?
                                 dialogueHistories[currentNpcId].slice(-10).map(d => `${d.speakerName}: ${d.utterance}`) :
                                 dialogueHistory.slice(-10).map(d => `${d.speakerName}: ${d.utterance}`); // Fallback or choose one source

            const payload = {
                scene_context: sceneContext,
                player_utterance: playerUtterance,
                active_pcs: activePCsInfo.map(pc => pc.name), // Consider sending PC objects if more detail is needed by AI
                recent_dialogue_history: npcSpecificRecentHistory,
                other_active_npcs_dialogue: otherActiveNpcsDialogueSummary,
                npc_history: currentNpc.combined_history_content || "" // <<< ADD THIS LINE
            };

            promises.push(
                fetch(`${API_BASE_URL}/api/npcs/${currentNpcId}/dialogue`, {
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify(payload)
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(errData => {
                            const error = new Error(errData.error || `HTTP error ${response.status} for ${currentNpc.name}`);
                            error.response = response; 
                            error.data = errData;
                            throw error;
                        }).catch((parseError) => { 
                            throw new Error(`HTTP error ${response.status} for ${currentNpc.name} and failed to parse error response.`);
                        });
                    }
                    return response.json().then(data => ({ok: true, data, npcId: currentNpcId, npcName: currentNpc.name }));
                })
                .catch(error => {
                    return {ok: false, error: error.message || 'Network error or failed to parse response', npcId: currentNpcId, npcName: currentNpc.name };
                })
            );
        });

        try {
            const results = await Promise.all(promises);
            results.forEach(result => {
                if (result.ok && result.data) {
                    addDialogueToTranscript(result.data.npc_dialogue, 'npc', result.npcName, result.npcId);
                    dialogueHistory.push({ type: 'npc', speakerName: result.npcName, id: result.npcId, utterance: result.data.npc_dialogue });
                    if(!dialogueHistories[result.npcId]) dialogueHistories[result.npcId] = [];
                    dialogueHistories[result.npcId].push({ type: 'npc', speakerName: result.npcName, id: result.npcId, utterance: result.data.npc_dialogue });
                    if (result.data.new_memory_suggestions || result.data.generated_topics) { 
                        renderAISuggestions(result.data.new_memory_suggestions, result.data.generated_topics);
                    }
                } else {
                    addDialogueToTranscript(`Error for ${result.npcName}: ${result.error}`, 'system-error', 'System', result.npcId);
                }
            });
            getElem('player-utterance').value = ''; 
        } catch (error) {
            console.error('Overall error in generateDialogue Promise.all processing:', error);
        } finally {
             disableBtn('generate-dialogue-btn', activeSceneNpcIds.size === 0);
        }
    }

    function addDialogueToTranscript(text, type, speakerName, targetNpcId = null) {
        const addToSpecificTranscript = (npcId) => {
            const transcriptDiv = getElem(`transcript-${npcId}`);
            if (!transcriptDiv) {
                console.warn(`Transcript div not found for NPC ID: ${npcId}`);
                return;
            }
            const entry = document.createElement('div'); 
            entry.classList.add('dialogue-entry');
            
            let speakerPrefix = "";
            if (type === 'player') {
                entry.classList.add('player-utterance');
                speakerPrefix = `${speakerName || 'Player'}: `;
            } else if (type === 'npc') { 
                entry.classList.add('npc-response');
                speakerPrefix = `${speakerName || 'NPC'}: `; 
            } else if (type === 'system-error') {
                entry.classList.add('scene-event'); 
                entry.style.color = 'red';
                speakerPrefix = `${speakerName || 'System'}: `;
            }
            
            const strongSpeaker = document.createElement('strong');
            strongSpeaker.textContent = speakerPrefix;
            entry.appendChild(strongSpeaker);
            entry.appendChild(document.createTextNode(text));

            const initialMessage = transcriptDiv.querySelector('p.scene-event');
            if (initialMessage) {
                initialMessage.remove();
            }
            transcriptDiv.appendChild(entry);
            transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
        };

        if (type === 'player') {
            activeSceneNpcIds.forEach(npcId => {
                addToSpecificTranscript(npcId);
            });
        } else if (targetNpcId) { 
            addToSpecificTranscript(targetNpcId);
        }
    }


   function renderAISuggestions(memorySuggestions, topicSuggestions) {
        const memListDiv = getElem('suggested-memories-list');
        memListDiv.innerHTML = '<strong>Suggested Memories (click to add):</strong>';
        if (memorySuggestions && memorySuggestions.length > 0) {
            const ul = document.createElement('ul');
            memorySuggestions.forEach(sugg => {
                const li = document.createElement('li');
                li.className = 'suggested-item clickable-suggestion';
                li.textContent = sugg;
                li.onclick = () => populateAddMemoryForm(sugg, 'ai_suggestion');
                ul.appendChild(li);
            });
            memListDiv.appendChild(ul);
        } else {
            memListDiv.innerHTML += '<p><em>None for now.</em></p>';
        }

        const topicListDiv = getElem('suggested-topics-list');
        topicListDiv.innerHTML = '<strong>Suggested Topics (click to use as player utterance):</strong>';
        if (topicSuggestions && topicSuggestions.length > 0) {
             const ul = document.createElement('ul');
            topicSuggestions.forEach(sugg => {
                const li = document.createElement('li');
                li.className = 'suggested-item clickable-suggestion';
                li.textContent = sugg;
                li.onclick = () => { 
                    getElem('player-utterance').value = `Tell me more about ${sugg}.`;
                    getElem('player-utterance').focus();
                };
                ul.appendChild(li);
            });
            topicListDiv.appendChild(ul);
        } else {
            topicListDiv.innerHTML += '<p><em>None for now.</em></p>';
        }
    }
    
    function populateAddMemoryForm(content, type) {
        if (!currentProfileCharId) {
             alert("View an NPC's details in the Profile section to add a memory to them.");
             return;
        }
        const characterForMemory = allCharacters.find(c => c._id === currentProfileCharId);
        if (!characterForMemory || characterForMemory.character_type !== 'NPC') {
            alert("Memories can only be added to NPCs currently viewed in the profile.");
            return;
        }
        getElem('new-memory-content').value = content;
        getElem('new-memory-type').value = type;
        getElem('new-memory-content').focus();
    }
</script>

</body>
</html>
