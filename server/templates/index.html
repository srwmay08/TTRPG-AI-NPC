<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bugbear Banter GM Interface</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; display: flex; height: 100vh; background-color: #f4f4f4; }
        .column { padding: 15px; overflow-y: auto; box-sizing: border-box; }
        #left-column { width: 25%; background-color: #e9e9e9; border-right: 1px solid #ccc; }
        #center-column { width: 50%; background-color: #fff; border-right: 1px solid #ccc; display: flex; flex-direction: column; }
        #right-column { width: 25%; background-color: #f0f0f0; }
        
        h2, h3 { margin-top: 0; color: #333; }
        button { padding: 8px 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 5px; }
        button:hover { background-color: #0056b3; }
        textarea, input[type="text"], input[type="number"], select { width: calc(100% - 16px); padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;} /* Added select */
        label { display: inline; margin-bottom: 5px; font-weight: bold; }

        #character-list ul { list-style-type: none; padding: 0; } /* Renamed from npc-list */
        #character-list li { padding: 8px; cursor: pointer; border-bottom: 1px solid #ddd; }
        #character-list li:hover, #character-list li.selected { background-color: #d1e7ff; }
        #character-list li .char-type { font-size: 0.8em; color: #555; margin-left: 5px; }


        #dialogue-transcript { flex-grow: 1; border: 1px solid #eee; padding: 10px; margin-bottom:10px; overflow-y: auto; background-color: #f9f9f9; min-height: 200px; }
        .dialogue-entry { margin-bottom: 8px; padding: 5px; border-radius: 3px; }
        .player-utterance { background-color: #e1f7d5; text-align: right; }
        .npc-response { background-color: #ddebf7; }
        .scene-event { font-style: italic; color: #777; text-align: center; margin:10px 0; }

        .memory-item, .suggested-item { background-color: #fff; border: 1px solid #eee; padding: 5px; margin-bottom: 5px; border-radius: 3px; font-size:0.9em; display: flex; justify-content: space-between; align-items: center; }
        .memory-item button, .suggested-item button { font-size: 0.8em; padding: 3px 6px; margin-left: 5px; }
        .clickable-suggestion { cursor: pointer; text-decoration: underline; color: blue; }
        
        #active-pc-selection div { margin-bottom: 5px; }
        #active-pc-selection label { margin-left: 5px; font-weight: normal;}
    </style>
</head>
<body>

    <div id="left-column" class="column">
        <h2>Characters</h2>
        <div id="create-character-form">
            <h3>Active Player Characters</h3>
            <div id="active-pc-selection">
                <p><em>No Player Characters defined yet. Create characters with type "PC".</em></p>
            </div>
            <h3>Create New Character</h3>
            <label for="new-char-name">Name:</label>
            <input type="text" id="new-char-name" required>
            <label for="new-char-description">Description:</label>
            <textarea id="new-char-description" rows="3" required></textarea>
            <label for="new-char-personality">Personality (comma-separated):</label>
            <input type="text" id="new-char-personality">
            <label for="new-char-type">Character Type:</label> <select id="new-char-type">
                <option value="NPC" selected>NPC (Non-Player Character)</option>
                <option value="PC">PC (Player Character)</option>
            </select>
            <button onclick="createCharacter()">Create Character</button> </div>
        <hr>
        <h3>Character List</h3>
        <div id="character-list"><ul></ul></div>
    </div>

    <div id="center-column" class="column">
        <h2>Scene Interaction</h2>
        <div id="scene-setup">
            
            <label for="scene-context">Dynamic Scene Context:</label>
            <textarea id="scene-context" rows="4" placeholder="Describe the current environment, mood, ongoing events..."></textarea>
        </div>
        <hr>
        <h3>Dialogue with <span id="active-npc-name">No NPC Selected</span></h3>
        <div id="dialogue-transcript">
            <p class="scene-event">Select an NPC from the list to begin interaction.</p>
        </div>
        <div id="dialogue-input-area">
            <label for="player-utterance">Player Says:</label>
            <textarea id="player-utterance" rows="2" placeholder="Enter player dialogue here..."></textarea>
            <button onclick="generateDialogue()" id="generate-dialogue-btn" disabled>Send to NPC</button>
        </div>
        <div id="ai-suggestions">
            <h4>AI Suggestions:</h4>
            <div id="suggested-memories-list"></div>
            <div id="suggested-topics-list"></div>
        </div>
    </div>

    <div id="right-column" class="column">
        <h2>Character Details: <span id="details-char-name">None</span></h2>
        <div id="char-profile-display"> <p><strong>Type:</strong> <span id="profile-char-type"></span></p> <p><strong>Description:</strong> <span id="profile-description"></span></p>
            <p><strong>Personality:</strong> <span id="profile-personality"></span></p>
        </div>
        <hr>
        <h3>GM Notes</h3>
        <textarea id="gm-notes" rows="5" placeholder="Private notes for this character..."></textarea>
        <button onclick="saveGMNotes()" id="save-gm-notes-btn" disabled>Save Notes</button>
        <hr>
        <div id="npc-specific-details"> <h3>NPC Memories</h3>
            <div id="add-memory-form">
                <label for="new-memory-content">Add Custom Memory:</label>
                <input type="text" id="new-memory-content" placeholder="Fact, event, observation...">
                <input type="text" id="new-memory-type" placeholder="Type (e.g., fact, seen)">
                <button onclick="addMemoryToCharacter()" id="add-memory-btn" disabled>Add Memory</button> </div>
            <div id="character-memories-list"> </div>
        </div>
        <hr>
        <h3>World Lore (Placeholder)</h3>
        <p><em>Lore linking and management UI to be implemented.</em></p>
    </div>

<script>
    let selectedCharacterId = null; // Renamed from selectedNPCId
    let allCharacters = []; // Renamed from allNPCs
    let dialogueHistory = []; // --- THIS IS THE FIX ---

    const API_BASE_URL = ''; 
    function getElem(id) { return document.getElementById(id); }
    function updateText(id, text) { getElem(id).textContent = text; }
    function disableBtn(id, disabled) { getElem(id).disabled = disabled; }

    async function fetchCharacters() { // Renamed
        try {
            const response = await fetch(`${API_BASE_URL}/api/npcs`); // Endpoint name is still /api/npcs
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            allCharacters = await response.json();
            renderCharacterList();
            renderPCSelection(); // NEW: Update PC selection checkboxes
        } catch (error) {
            console.error('Error fetching characters:', error);
            alert('Failed to load characters.');
        }
    }

    function renderCharacterList() { // Renamed
        const ul = getElem('character-list').querySelector('ul');
        ul.innerHTML = ''; 
        allCharacters.forEach(char => {
            const li = document.createElement('li');
            li.innerHTML = `${char.name} <span class="char-type">(${char.character_type || 'NPC'})</span>`; // Display type
            li.dataset.charId = char._id; 
            li.onclick = () => selectCharacter(char._id); // Renamed
            if (char._id === selectedCharacterId) {
                li.classList.add('selected');
            }
            ul.appendChild(li);
        });
    }

    function renderPCSelection() {
        const pcSelectionDiv = getElem('active-pc-selection');
        pcSelectionDiv.innerHTML = ''; // Clear previous
        const pcs = allCharacters.filter(char => char.character_type === 'PC');

        if (pcs.length === 0) {
            pcSelectionDiv.innerHTML = '<p><em>No Player Characters defined yet. Create characters with type "PC".</em></p>';
            return;
        }

        pcs.forEach(pc => {
            const div = document.createElement('div');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `pc-checkbox-${pc._id}`;
            checkbox.value = pc._id; // Store ID, could also use name
            checkbox.name = 'active_pc';
            
            const label = document.createElement('label');
            label.htmlFor = `pc-checkbox-${pc._id}`;
            label.textContent = pc.name;

            div.appendChild(checkbox);
            div.appendChild(label);
            pcSelectionDiv.appendChild(div);
        });
    }


    async function createCharacter() { // Renamed
        const name = getElem('new-char-name').value;
        const description = getElem('new-char-description').value;
        const personality = getElem('new-char-personality').value.split(',').map(s => s.trim()).filter(s => s);
        const characterType = getElem('new-char-type').value; // Get selected type

        if (!name || !description) {
            alert('Character Name and Description are required.');
            return;
        }

        try {
            const response = await fetch(`${API_BASE_URL}/api/npcs`, { // Endpoint still /api/npcs
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, description, character_type: characterType, personality_traits: personality, memories: [], gm_notes: "" })
            });
            if (!response.ok) {
                 const errorData = await response.json();
                 throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }
            const result = await response.json();
            alert(result.message);
            fetchCharacters(); 
            getElem('new-char-name').value = '';
            getElem('new-char-description').value = '';
            getElem('new-char-personality').value = '';
            getElem('new-char-type').value = 'NPC'; // Reset dropdown
        } catch (error) {
            console.error('Error creating character:', error);
            alert(`Failed to create character: ${error.message}`);
        }
    }

    function selectCharacter(charId) { // Renamed
        selectedCharacterId = charId;
        const selectedChar = allCharacters.find(char => char._id === charId);
        renderCharacterList(); 

        const npcSpecificDetailsDiv = getElem('npc-specific-details');

        if (selectedChar) {
            updateText('details-char-name', selectedChar.name);
            updateText('profile-char-type', selectedChar.character_type); // Display type
            updateText('profile-description', selectedChar.description);
            updateText('profile-personality', selectedChar.personality_traits.join(', '));
            getElem('gm-notes').value = selectedChar.gm_notes || '';
            
            disableBtn('save-gm-notes-btn', false);

            if (selectedChar.character_type === 'NPC') {
                updateText('active-npc-name', selectedChar.name);
                renderMemories(selectedChar.memories || []);
                disableBtn('generate-dialogue-btn', false);
                disableBtn('add-memory-btn', false);
                getElem('dialogue-transcript').innerHTML = `<p class="scene-event">Interacting with NPC: ${selectedChar.name}.</p>`;
                npcSpecificDetailsDiv.style.display = 'block'; // Show NPC specific sections
            } else { // It's a PC
                updateText('active-npc-name', 'None (PC Selected)');
                getElem('dialogue-transcript').innerHTML = `<p class="scene-event">Selected PC: ${selectedChar.name}. PCs do not generate AI dialogue directly. Their presence influences NPC dialogue.</p>`;
                getElem('character-memories-list').innerHTML = '<p><em>Memories are typically managed for NPCs.</em></p>';
                disableBtn('generate-dialogue-btn', true);
                disableBtn('add-memory-btn', true);
                npcSpecificDetailsDiv.style.display = 'none'; // Hide NPC specific sections
            }
        } else {
            // Reset UI if no character or invalid ID somehow
            updateText('active-npc-name', 'No NPC Selected');
            updateText('details-char-name', 'None');
            disableBtn('generate-dialogue-btn', true);
            disableBtn('save-gm-notes-btn', true);
            disableBtn('add-memory-btn', true);
            npcSpecificDetailsDiv.style.display = 'block'; // Default show
        }
    }

    async function saveGMNotes() {
        if (!selectedCharacterId) return;
        const notes = getElem('gm-notes').value;
        try {
            const response = await fetch(`${API_BASE_URL}/api/npcs/${selectedCharacterId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ gm_notes: notes })
            });
            if (!response.ok) throw new Error('Failed to save notes');
            const result = await response.json();
            alert(result.message);
            const charIndex = allCharacters.findIndex(char => char._id === selectedCharacterId);
            if (charIndex > -1) allCharacters[charIndex].gm_notes = notes;
        } catch (error) {
            console.error('Error saving GM notes:', error);
            alert('Failed to save GM notes.');
        }
    }
    
    function renderMemories(memories) {
        const listDiv = getElem('character-memories-list'); // Renamed ID
        listDiv.innerHTML = '<h4>Current Memories:</h4>';
        if (!memories || memories.length === 0) {
            listDiv.innerHTML += '<p>No memories yet.</p>';
            return;
        }
        memories.forEach(mem => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'memory-item';
            itemDiv.innerHTML = `
                <span>(${new Date(mem.timestamp).toLocaleTimeString()}) [${mem.type}] ${mem.content}</span>
                <button onclick="deleteMemory('${mem.memory_id}')">Undo</button>
            `;
            listDiv.appendChild(itemDiv);
        });
    }

    async function addMemoryToCharacter(content = null, type = null) { // Renamed
        if (!selectedCharacterId) return;
        const selectedChar = allCharacters.find(char => char._id === selectedCharacterId);
        if(selectedChar && selectedChar.character_type !== 'NPC') {
            alert("Memories are typically added to NPCs.");
            return;
        }
        
        const memoryContent = content || getElem('new-memory-content').value;
        const memoryType = type || getElem('new-memory-type').value || 'manual_fact';

        if (!memoryContent) {
            alert('Memory content cannot be empty.');
            return;
        }

        try {
            const response = await fetch(`${API_BASE_URL}/api/npcs/${selectedCharacterId}/memory`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content: memoryContent, type: memoryType, source: 'gm_interface_manual' })
            });
            const result = await response.json();
            if (!response.ok) {
                 throw new Error(result.error || `Failed to add memory. Status: ${response.status}`);
            }
            alert(result.message || 'Memory added!');
            renderMemories(result.updated_memories || []);
            const charIndex = allCharacters.findIndex(char => char._id === selectedCharacterId);
            if (charIndex > -1) allCharacters[charIndex].memories = result.updated_memories;

            if (!content) getElem('new-memory-content').value = ''; 
            if (!type) getElem('new-memory-type').value = '';

        } catch (error) {
            console.error('Error adding memory:', error);
            alert(`Failed to add memory: ${error.message}`);
        }
    }
    
    async function deleteMemory(memoryId) {
        if (!selectedCharacterId || !memoryId) return;
        const selectedChar = allCharacters.find(char => char._id === selectedCharacterId);
         if(selectedChar && selectedChar.character_type !== 'NPC') {
            // This case should ideally not be reached if buttons are disabled for PCs
            alert("Cannot delete memories for a PC.");
            return;
        }
        if (!confirm('Are you sure you want to delete this memory?')) return;

        try {
            const response = await fetch(`${API_BASE_URL}/api/npcs/${selectedCharacterId}/memory/${memoryId}`, {
                method: 'DELETE'
            });
            const result = await response.json();
            if (!response.ok) {
                 throw new Error(result.error || `Failed to delete memory. Status: ${response.status}`);
            }
            alert(result.message || 'Memory deleted!');
            renderMemories(result.updated_memories || []);
            const charIndex = allCharacters.findIndex(char => char._id === selectedCharacterId);
            if (charIndex > -1) allCharacters[charIndex].memories = result.updated_memories;
        } catch (error) {
            console.error('Error deleting memory:', error);
            alert(`Failed to delete memory: ${error.message}`);
        }
    }

    async function generateDialogue() {
        if (!selectedCharacterId) {
            alert('Please select an NPC first.');
            return;
        }
        const selectedChar = allCharacters.find(char => char._id === selectedCharacterId);
        if (!selectedChar || selectedChar.character_type !== 'NPC') {
            alert('Dialogue can only be generated for NPCs.');
            return;
        }

        const sceneContext = getElem('scene-context').value;
        const playerUtterance = getElem('player-utterance').value;
        
        // Get selected PCs
        const activePCInputs = document.querySelectorAll('#active-pc-selection input[name="active_pc"]:checked');
        const activePCIds = Array.from(activePCInputs).map(input => input.value);
        const activePCNames = activePCIds.map(id => {
            const pc = allCharacters.find(char => char._id === id);
            return pc ? pc.name : 'Unknown PC';
        });


        if (!sceneContext) {
            alert('Scene context is required.');
            return;
        }
        
        addDialogueToTranscript(playerUtterance, 'player');
        dialogueHistory.push(`Player: ${playerUtterance}`);

        const payload = {
            // npc_id: selectedCharacterId, // Backend uses the ID from the URL
            scene_context: sceneContext,
            player_utterance: playerUtterance,
            active_pcs: activePCNames, // Send names of selected PCs
            recent_dialogue_history: dialogueHistory.slice(-5)
        };

        try {
            disableBtn('generate-dialogue-btn', true);
            const response = await fetch(`${API_BASE_URL}/api/npcs/${selectedCharacterId}/dialogue`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            if (!response.ok) {
                 throw new Error(result.error || `Failed to generate dialogue. Status: ${response.status}`);
            }

            addDialogueToTranscript(result.npc_dialogue, 'npc');
            dialogueHistory.push(`NPC (${selectedChar.name}): ${result.npc_dialogue}`);
            getElem('player-utterance').value = ''; 
            renderAISuggestions(result.new_memory_suggestions, result.generated_topics);
        } catch (error) {
            console.error('Error generating dialogue:', error);
            alert(`Dialogue generation failed: ${error.message}`);
            addDialogueToTranscript(`Error: ${error.message}`, 'system-error');
        } finally {
            disableBtn('generate-dialogue-btn', false);
        }
    }

    function addDialogueToTranscript(text, type) {
        const transcriptDiv = getElem('dialogue-transcript');
        const entry = document.createElement('div');
        entry.classList.add('dialogue-entry');
        let speaker = "";
        const activeNPCName = getElem('active-npc-name').textContent;


        if (type === 'player') {
            entry.classList.add('player-utterance');
            speaker = "You (Player): ";
        } else if (type === 'npc') {
            entry.classList.add('npc-response');
            speaker = `${activeNPCName || 'NPC'}: `;
        } else if (type === 'scene-event' || type === 'system-error') {
            entry.classList.add('scene-event');
            if (type === 'system-error') entry.style.color = 'red';
        }
        // Sanitize text if it might contain HTML, for now assuming it's plain text
        const strong = document.createElement('strong');
        strong.textContent = speaker;
        entry.appendChild(strong);
        entry.appendChild(document.createTextNode(text));
        
        if (transcriptDiv.childElementCount === 1 && transcriptDiv.firstChild.classList.contains('scene-event')) {
            transcriptDiv.innerHTML = '';
        }
        transcriptDiv.appendChild(entry);
        transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
    }

    function renderAISuggestions(memorySuggestions, topicSuggestions) {
        const memList = getElem('suggested-memories-list');
        memList.innerHTML = '<strong>Suggested Memories (click to use):</strong>';
        if (memorySuggestions && memorySuggestions.length > 0) {
            memorySuggestions.forEach(sugg => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'suggested-item clickable-suggestion';
                itemDiv.textContent = sugg;
                itemDiv.onclick = () => populateAddMemoryForm(sugg, 'ai_suggestion');
                memList.appendChild(itemDiv);
            });
        } else {
            memList.innerHTML += '<p>None.</p>';
        }

        const topicList = getElem('suggested-topics-list');
        topicList.innerHTML = '<strong>Suggested Topics (click to use):</strong>';
         if (topicSuggestions && topicSuggestions.length > 0) {
            topicSuggestions.forEach(sugg => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'suggested-item clickable-suggestion';
                itemDiv.textContent = sugg;
                itemDiv.onclick = () => { 
                    getElem('player-utterance').value = `Tell me more about ${sugg}.`;
                };
                topicList.appendChild(itemDiv);
            });
        } else {
            topicList.innerHTML += '<p>None.</p>';
        }
    }
    
    function populateAddMemoryForm(content, type) {
        const selectedChar = allCharacters.find(char => char._id === selectedCharacterId);
        if(selectedChar && selectedChar.character_type !== 'NPC') {
            alert("Memories are typically added to NPCs. Cannot auto-populate for a PC.");
            return;
        }
        getElem('new-memory-content').value = content;
        getElem('new-memory-type').value = type;
        getElem('new-memory-content').focus();
    }

    window.onload = () => {
        fetchCharacters(); // Renamed function
    };

    
    async function fetchCharacters() {
        try {
            const response = await fetch(`${API_BASE_URL}/api/npcs`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            allCharacters = await response.json();
            
            // ADD THIS LINE FOR DEBUGGING
            console.log("Characters received by frontend:", allCharacters); 

            renderCharacterList();
            renderPCSelection();
        } catch (error) {
            console.error('Error fetching characters:', error);
            alert('Failed to load characters.');
        }
    }
    
</script>

</body>
</html>