<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bugbear Banter GM Interface</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; display: flex; height: 100vh; background-color: #f4f4f4; overflow: hidden; }
        .column { overflow-y: auto; box-sizing: border-box; }
        
        #left-column {
            width: 30%; /* Initial width */
            min-width: 250px; /* User cannot drag smaller than this */
            max-width: 60%;  /* User cannot drag larger than this */
            background-color: #e9e9e9;
            border-right: 1px solid #ccc;
            height: 100vh;
            padding: 0; 
        }

        #left-column-content { padding: 15px; height: 100%; overflow-y: auto; }

        #resizer {
            width: 10px; 
            background-color: #d0d0d0;
            cursor: col-resize;
            border-right: 1px solid #ccc;
            user-select: none; 
        }
        #resizer:hover { background-color: #007bff; }

        #center-column {
            flex-grow: 1; 
            background-color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 15px;
        }

        .collapsible-section h3 { cursor: pointer; background-color: #d8d8d8; padding: 8px; margin: 10px 0 5px 0; user-select: none; position: relative; }
        .collapsible-section h3::after { content: ' ▼'; float: right; }
        .collapsible-section.collapsed .collapsible-content { display: none; }
        .collapsible-section.collapsed h3::after { content: ' ►'; }

        h2, h3, h4 { margin-top: 0; color: #333; }
        h5 { margin-top: 0; margin-bottom: 10px; color: #333; }
        button { padding: 8px 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 5px; }
        button:hover { background-color: #0056b3; }
        textarea, input[type="text"], input[type="number"], select { width: calc(100% - 16px); padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;}
        label { display: block; margin-bottom: 5px; font-weight: bold; }

        .character-list ul { list-style-type: none; padding: 0; max-height: 180px; overflow-y: auto; border: 1px solid #ddd; background: #fff; }
        .character-list li { padding: 8px; cursor: pointer; border-bottom: 1px solid #ddd; }
        .character-list li:last-child { border-bottom: none; }
        .character-list li:hover, .character-list li.selected { background-color: #d1e7ff; }

        #dialogue-interface { display: none; flex-grow: 1; display: flex; flex-direction: column; }
        #dialogue-transcript { flex-grow: 1; border: 1px solid #eee; padding: 10px; margin-bottom:10px; overflow-y: auto; background-color: #f9f9f9; min-height: 200px; }
        .dialogue-entry { margin-bottom: 8px; padding: 5px; border-radius: 3px; }
        .player-utterance { background-color: #e1f7d5; text-align: right; }
        .npc-response { background-color: #ddebf7; }
        .scene-event { font-style: italic; color: #777; text-align: center; margin:10px 0; }

        .memory-item, .suggested-item { background-color: #fff; border: 1px solid #eee; padding: 5px; margin-bottom: 5px; border-radius: 3px; font-size:0.9em; display: flex; justify-content: space-between; align-items: center; }
        .memory-item button, .suggested-item button { font-size: 0.8em; padding: 3px 6px; margin-left: 5px; }
        .clickable-suggestion { cursor: pointer; text-decoration: underline; color: blue; }
        
        /* PC Dashboard Styles */
        #pc-dashboard-view { display: block; flex-grow: 1; overflow-y: auto; }
        .pc-dashboard-grid { display: flex; flex-wrap: wrap; gap: 15px; margin-top: 20px; margin-right: 10px}
        .pc-stat-card { border: 1px solid #ddd; border-radius: 4px; padding: 15px; background-color: #f9f9f9; flex: 1 1 200px; min-width: 130px; }
        .pc-stat-card h4 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-bottom: 10px; }
        .pc-stat-card p { margin: 5px 0; }
        .pc-stat-card ul { list-style-type: none; padding-left: 0; }
        .pc-stat-card li { padding: 3px 0; }
        .pc-dashboard-no-selection { text-align: center; color: #777; margin-top: 50px; font-size: 1.2em;}

        /* Main Stats Table */
        #main-stats-table { width: 99%; border-collapse: collapse; margin-bottom: 0; /* Adjusted margin */ font-size: 0.9em; }
        #main-stats-table th, #main-stats-table td { border: 1px solid #ddd; padding: 6px; text-align: center; }
        #main-stats-table th { background-color: #e9ecef; font-weight: bold; }
        #main-stats-table td:first-child { text-align: left; font-weight: bold; }
        .clickable-ability-header { cursor: pointer; color: #0056b3; text-decoration: underline;}
        .clickable-ability-header span.arrow-indicator { font-size: 0.8em; margin-left: 3px;}

        /* Expanded Ability Details Section */
        .expanded-ability-content {
            border: 1px solid #ccc;
            border-top: none; /* Remove top border as it's now visually grouped with table */
            padding: 15px;
            margin-bottom: 10px;
            background-color: #f8f9fa;
        }
        .expanded-ability-content h5 { 
            margin-top:0; 
            margin-bottom: 10px; 
            border-bottom: 1px solid #eee; 
            padding-bottom: 5px;
            font-size: 1.1em;
        }
        
        .ability-bar-chart-container { margin-bottom: 20px; padding: 10px 0px; } /* Added padding */
        .pc-bar-row { display: flex; align-items: center; margin-bottom: 3px; font-size: 0.9em; }
        .stat-comparison-pc-name { width: 120px; text-align: right; margin-right: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .stat-bar-wrapper { flex-grow: 1; background-color: #e0e0e0; border-radius: 3px; height: 18px; min-width: 80px; }
        .stat-bar { height: 100%; background-color: #007bff; border-radius: 3px; text-align: right; padding-right: 5px; color: white; line-height: 18px; font-size: 0.8em; white-space: nowrap; overflow: hidden;}
        
        .derived-stats-table { width: 100%; border-collapse: collapse; font-size: 0.9em; margin-top:10px;}
        .derived-stats-table th, .derived-stats-table td { border: 1px solid #ddd; padding: 5px; text-align: left; }
        .derived-stats-table th { background-color: #f1f1f1; } /* Keep header distinct */
        .derived-stats-table td { text-align: center; }
        .derived-stats-table th:first-child { font-weight: bold; text-align: left; width: 180px;} /* Metric name column */

        .associated-skills-list { list-style-type: disc; padding-left: 20px; margin-top: 5px; font-size: 0.9em; }
        .associated-skills-list li { border-bottom: none; padding: 2px 0; }


    </style>
</head>
<body>
    <div id="left-column" class="column">
        <div id="left-column-content">
            <h2>Characters & Details</h2>
            <div id="pc-list-section" class="collapsible-section">
                <h3>Active Player Characters</h3>
                <div class="collapsible-content character-list">
                    <div id="active-pc-list"><p><em>Loading PCs...</em></p></div>
                </div>
            </div>
            <div id="npc-list-section" class="collapsible-section">
                <h3>NPC List (for Dialogue)</h3>
                <div class="collapsible-content character-list">
                    <div id="character-list"><ul><li><em>Loading NPCs...</em></li></ul></div>
                </div>
            </div>
            <div id="character-details-section" class="collapsible-section">
                <h3>Details: <span id="details-char-name">None</span></h3>
                <div class="collapsible-content">
                    <div id="char-profile-display">
                        <p><strong>Type:</strong> <span id="profile-char-type"></span></p>
                        <p><strong>Description:</strong> <span id="profile-description"></span></p>
                        <p><strong>Personality:</strong> <span id="profile-personality"></span></p>
                    </div>
                    <hr>
                    <h3>GM Notes</h3>
                    <textarea id="gm-notes" rows="3" placeholder="Private notes for this character..."></textarea>
                    <button onclick="saveGMNotes()" id="save-gm-notes-btn" disabled>Save Notes</button>
                    <hr>
                    <div id="npc-specific-details">
                        <h3>NPC Memories</h3>
                        <div id="add-memory-form">
                            <label for="new-memory-content">Add Custom Memory:</label>
                            <input type="text" id="new-memory-content" placeholder="Fact, event, observation...">
                            <input type="text" id="new-memory-type" placeholder="Type (e.g., fact, seen)">
                            <button onclick="addMemoryToCharacter()" id="add-memory-btn" disabled>Add Memory</button>
                        </div>
                        <div id="character-memories-list"></div>
                    </div>
                </div>
            </div>
            
            <div id="create-character-section" class="collapsible-section collapsed">
                <h3>Create New Character</h3>
                <div id="create-character-form" class="collapsible-content">
                    <label for="new-char-name">Name:</label>
                    <input type="text" id="new-char-name" required>
                    <label for="new-char-description">Description:</label>
                    <textarea id="new-char-description" rows="3" required></textarea>
                    <label for="new-char-personality">Personality (comma-separated):</label>
                    <input type="text" id="new-char-personality">
                    <label for="new-char-type">Character Type:</label>
                    <select id="new-char-type">
                        <option value="NPC" selected>NPC (Non-Player Character)</option>
                        <option value="PC">PC (Player Character)</option>
                    </select>
                    <button onclick="createCharacter()">Create Character</button>
                </div>
            </div>
        </div>
    </div>

    <div id="resizer"></div>

    <div id="center-column" class="column">
        <div id="dialogue-interface">
            <h2>Scene Interaction</h2>
            <div id="scene-setup">
                <label for="scene-context">Dynamic Scene Context:</label>
                <textarea id="scene-context" rows="4" placeholder="Describe the current environment, mood, ongoing events..."></textarea>
            </div>
            <hr>
            <h3>Dialogue with <span id="active-npc-name">No NPC Selected</span></h3>
            <div id="dialogue-transcript">
                <p class="scene-event">Select an NPC from the list to begin interaction.</p>
            </div>
            <div id="dialogue-input-area">
                <label for="player-utterance">Player Says:</label>
                <textarea id="player-utterance" rows="2" placeholder="Enter player dialogue here..."></textarea>
                <button onclick="generateDialogue()" id="generate-dialogue-btn" disabled>Send to NPC</button>
            </div>
            <div id="ai-suggestions">
                <h4>AI Suggestions:</h4>
                <div id="suggested-memories-list"></div>
                <div id="suggested-topics-list"></div>
            </div>
        </div>

        <div id="pc-dashboard-view">
            <h2>Player Character Dashboard</h2>
            <div id="pc-dashboard-content">
                <p class="pc-dashboard-no-selection">Select Player Characters from the left panel to view their details and comparisons.</p>
            </div>
        </div>
    </div>

<script>
    console.log("Script execution started."); 

    let selectedNpcId = null;
    let activePcIds = new Set();
    let allCharacters = [];
    let dialogueHistory = [];
    let currentlyExpandedAbility = null; 

    const API_BASE_URL = ''; 
    function getElem(id) { return document.getElementById(id); }
    function updateText(id, text) { getElem(id).textContent = text; }
    function disableBtn(id, disabled) { getElem(id).disabled = disabled; }

    // --- D&D 5e Calculation Functions ---
    function getAbilityModifier(score) { return Math.floor((score - 10) / 2); }
    function carryingCapacity(score) { return score * 15; }
    function pushDragLift(score) { return score * 30; }
    function longJump(score, running = true) { return running ? score : Math.floor(score / 2); }
    function highJump(score, running = true) { const mod = getAbilityModifier(score); return running ? (3 + mod) : Math.floor((3 + mod) / 2); }
    function initiative(dexScore) { return getAbilityModifier(dexScore); }
    function holdBreath(conScore) { return Math.max(1 + getAbilityModifier(conScore), 0.5) + " minutes"; } 
    function spellSaveDC(castingStatScore, proficiencyBonus) { return 8 + getAbilityModifier(castingStatScore) + proficiencyBonus; }
    function spellAttackBonus(castingStatScore, proficiencyBonus) { return getAbilityModifier(castingStatScore) + proficiencyBonus; }
    function savingThrowBonus(abilityScore, proficientInSave = false, proficiencyBonus = 0) {
        const mod = getAbilityModifier(abilityScore);
        return mod + (proficientInSave ? proficiencyBonus : 0);
    }
    function calculatePassiveSkill(baseStatScore, skillProficiencyValue, proficiencyBonus) {
        const modifier = getAbilityModifier(baseStatScore);
        let skillBonus = 10 + modifier;
        if (skillProficiencyValue === 1 || skillProficiencyValue === 2) { 
            skillBonus += proficiencyBonus;
        } else if (skillProficiencyValue === 0.5) { 
            skillBonus += Math.floor(proficiencyBonus / 2);
        }
        return skillBonus;
    }

    function getProficiencyBonus(level) {
        if (level < 1) return 2; 
        if (level <= 4) return 2;
        if (level <= 8) return 3;
        if (level <= 12) return 4;
        if (level <= 16) return 5;
        return 6;
    }

    // --- Character Data & Rendering ---
    async function fetchCharacters() {
        console.log("fetchCharacters: Function entered.");
        try {
            console.log("fetchCharacters: Attempting fetch from " + `${API_BASE_URL}/api/npcs`);
            const response = await fetch(`${API_BASE_URL}/api/npcs`);
            console.log("fetchCharacters: Fetch response status - " + response.status);
            if (!response.ok) {
                console.error("fetchCharacters: Response not OK. Status: " + response.status);
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            allCharacters = await response.json();
            console.log('fetchCharacters: All characters data received and parsed:', JSON.parse(JSON.stringify(allCharacters)));
            renderNpcList();
            renderPcList();
            updateView(); 
        } catch (error) { 
            console.error('Error in fetchCharacters:', error); 
            alert('Failed to load characters. Check console for details: ' + error.message); 
        }
    }

    function renderNpcList() {
        const ul = getElem('character-list').querySelector('ul');
        ul.innerHTML = ''; 
        const npcs = allCharacters.filter(char => char.character_type === 'NPC');
        if (npcs.length === 0) { ul.innerHTML = '<li><p><em>No NPCs defined yet.</em></p></li>'; return; }
        npcs.forEach(char => {
            const li = document.createElement('li');
            li.textContent = char.name;
            li.dataset.charId = char._id; 
            li.onclick = () => selectNpcForDialogue(char._id);
            if (char._id === selectedNpcId) li.classList.add('selected');
            ul.appendChild(li);
        });
    }

    function renderPcList() {
        const pcListDiv = getElem('active-pc-list');
        pcListDiv.innerHTML = '';
        const pcs = allCharacters.filter(char => char.character_type === 'PC');
        if (pcs.length === 0) { 
            pcListDiv.innerHTML = '<p><em>No Player Characters defined yet. Create characters with type "PC".</em></p>'; 
            return; 
        }
        const ul = document.createElement('ul');
        pcs.forEach(pc => {
            const li = document.createElement('li');
            li.textContent = pc.name;
            li.dataset.charId = pc._id;
            li.onclick = () => {
                if (selectedNpcId) { 
                    selectedNpcId = null; 
                    const currentlySelectedNpcLi = document.querySelector('#character-list li.selected');
                    if (currentlySelectedNpcLi) {
                        currentlySelectedNpcLi.classList.remove('selected');
                    }
                    updateText('active-npc-name', 'No NPC Selected'); 
                    disableBtn('generate-dialogue-btn', true);
                }
                togglePcSelection(pc._id, li); 
                selectCharacterForDetails(pc._id); 
                updateView(); 
            };
            if (activePcIds.has(pc._id)) li.classList.add('selected');
            ul.appendChild(li);
        });
        pcListDiv.appendChild(ul);
    }
    
    function selectCharacterForDetails(charId) {
        const selectedChar = allCharacters.find(char => char._id === charId);
        if (selectedChar) {
            updateText('details-char-name', selectedChar.name);
            updateText('profile-char-type', selectedChar.character_type);
            updateText('profile-description', selectedChar.description);
            updateText('profile-personality', (selectedChar.personality_traits || []).join(', '));
            getElem('gm-notes').value = selectedChar.gm_notes || '';
            disableBtn('save-gm-notes-btn', false);
            const isNpc = selectedChar.character_type === 'NPC';
            getElem('npc-specific-details').style.display = isNpc ? 'block' : 'none';
            if (isNpc) {
                renderMemories(selectedChar.memories || []);
                disableBtn('add-memory-btn', false);
            } else {
                 disableBtn('add-memory-btn', true);
                 getElem('character-memories-list').innerHTML = '<p><em>Memories are typically managed for NPCs.</em></p>';
            }
        }
    }

    function togglePcSelection(pcId, element) {
        if (activePcIds.has(pcId)) {
            activePcIds.delete(pcId);
            element.classList.remove('selected');
        } else {
            activePcIds.add(pcId);
            element.classList.add('selected');
        }
        if(getElem('pc-dashboard-view').style.display !== 'none') {
            if (currentlyExpandedAbility) {
                const expansionDiv = document.getElementById(`expanded-${currentlyExpandedAbility}`);
                const selectedPcsForExpansion = allCharacters.filter(char => activePcIds.has(char._id) && char.character_type === 'PC' && char.vtt_data);
                if (expansionDiv && expansionDiv.style.display === 'block') { 
                    if (selectedPcsForExpansion.length > 0) {
                        populateExpandedAbilityDetails(currentlyExpandedAbility, expansionDiv, selectedPcsForExpansion);
                    } else { 
                        expansionDiv.style.display = 'none';
                        const headerTH = document.querySelector(`#main-stats-table th[data-ability="${currentlyExpandedAbility}"]`);
                        if (headerTH) headerTH.querySelector('span.arrow-indicator').textContent = ' ►';
                        currentlyExpandedAbility = null; 
                    }
                }
            }
            updatePcDashboard(); 
        }
    }
    
    // --- View Management ---
    function updateView() {
        const dialogueInterface = getElem('dialogue-interface');
        const pcDashboardView = getElem('pc-dashboard-view');
        if (selectedNpcId) {
            dialogueInterface.style.display = 'flex'; 
            pcDashboardView.style.display = 'none';
            if(currentlyExpandedAbility){ 
                const expansionDiv = document.getElementById(`expanded-${currentlyExpandedAbility}`);
                if(expansionDiv) expansionDiv.style.display = 'none';
                const headerTH = document.querySelector(`#main-stats-table th[data-ability="${currentlyExpandedAbility}"]`);
                if (headerTH) headerTH.querySelector('span.arrow-indicator').textContent = ' ►';
                currentlyExpandedAbility = null;
            }
        } else {
            dialogueInterface.style.display = 'none';
            pcDashboardView.style.display = 'block';
            updatePcDashboard(); 
        }
    }
    
    function selectNpcForDialogue(npcId) {
        selectedNpcId = npcId; 
        const selectedChar = allCharacters.find(char => char._id === npcId);
        if (selectedChar) {
            updateText('active-npc-name', selectedChar.name);
            disableBtn('generate-dialogue-btn', false);
            dialogueHistory = []; 
            getElem('dialogue-transcript').innerHTML = `<p class="scene-event">Interacting with NPC: ${selectedChar.name}.</p>`;
            selectCharacterForDetails(npcId); 
        }
        renderNpcList(); 
        updateView(); 
    }

    // --- PC Dashboard Logic ---
    function updatePcDashboard() {
        const dashboardContent = getElem('pc-dashboard-content');
        dashboardContent.innerHTML = ''; 

        const selectedPcs = allCharacters.filter(char => activePcIds.has(char._id) && char.character_type === 'PC' && char.vtt_data);

        if (selectedPcs.length === 0) {
            const anyPcsExist = allCharacters.some(char => char.character_type === 'PC' && char.vtt_data);
            dashboardContent.innerHTML = `<p class="pc-dashboard-no-selection">${anyPcsExist ? 'Select Player Characters from the left panel to view their details.' : 'No Player Characters with VTT data available. Create PCs and ensure VTT data is synced.'}</p>`;
            if (currentlyExpandedAbility) {
                const expansionDiv = document.getElementById(`expanded-${currentlyExpandedAbility}`);
                if (expansionDiv) expansionDiv.style.display = 'none'; // Ensure it's hidden
                // Reset arrow indicator on main table if it exists
                const headerTH = document.querySelector(`#main-stats-table th[data-ability="${currentlyExpandedAbility}"] .arrow-indicator`);
                if(headerTH) headerTH.textContent = ' ►';
                currentlyExpandedAbility = null;
            }
            return;
        }

        const abilities = ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'];

        let mainStatsTableHTML = `<h4>Player Stats Overview</h4>
                                  <table id="main-stats-table"><thead><tr><th>Character</th>`;
        abilities.forEach(ablKey => {
            const arrow = (currentlyExpandedAbility === ablKey && getElem(`expanded-${ablKey}`)?.style.display !== 'none') ? '▼' : '►';
            mainStatsTableHTML += `<th class="clickable-ability-header" data-ability="${ablKey}" onclick="toggleAbilityExpansion('${ablKey}')">${ablKey} <span class="arrow-indicator">${arrow}</span></th>`;
        });
        mainStatsTableHTML += `</tr></thead><tbody>`;
        
        const sortedSelectedPcsByName = [...selectedPcs].sort((a,b) => a.name.localeCompare(b.name));

        sortedSelectedPcsByName.forEach(pc => {
            mainStatsTableHTML += `<tr><td>${pc.name}</td>`;
            abilities.forEach(ablKey => {
                const score = pc.vtt_data.abilities[ablKey.toLowerCase()]?.value || 0;
                const mod = getAbilityModifier(score);
                mainStatsTableHTML += `<td>${score} (${mod >= 0 ? '+' : ''}${mod})</td>`;
            });
            mainStatsTableHTML += `</tr>`;
        });
        mainStatsTableHTML += `</tbody></table>`;
        
        const expansionContainer = document.createElement('div');
        expansionContainer.id = 'expanded-ability-details-sections';
        
        dashboardContent.innerHTML = mainStatsTableHTML;
        dashboardContent.appendChild(expansionContainer);

        abilities.forEach(ablKey => {
            const expansionDiv = document.createElement('div');
            expansionDiv.id = `expanded-${ablKey}`;
            expansionDiv.className = 'expanded-ability-content';
            expansionDiv.style.display = 'none'; // Ensure all are hidden initially by JS
            // Populate if it was the currently expanded one
            if (currentlyExpandedAbility === ablKey && selectedPcs.length > 0) {
                populateExpandedAbilityDetails(ablKey, expansionDiv, selectedPcs);
                expansionDiv.style.display = 'block'; // Set to block if it was open
            }
            expansionContainer.appendChild(expansionDiv);
        });
        
        let statCardsHTML = `<h4 style="margin-top: 20px;">Individual Stat Blocks</h4><div class="pc-dashboard-grid">`;
        sortedSelectedPcsByName.forEach(pc => {
            const pcLevel = pc.flags?.ddbimporter?.dndbeyond?.totalLevels || 1;
            const profBonus = getProficiencyBonus(pcLevel);
            statCardsHTML += `<div class="pc-stat-card"><h4>${pc.name} (Level ${pcLevel})</h4>`;
            const hpCurrent = pc.vtt_data.attributes.hp?.value !== undefined ? pc.vtt_data.attributes.hp.value : 'N/A';
            const hpMax = pc.vtt_data.attributes.hp?.max !== undefined && pc.vtt_data.attributes.hp.max !== null ? pc.vtt_data.attributes.hp.max : 'N/A';
            statCardsHTML += `<p><strong>HP:</strong> ${hpCurrent} / ${hpMax}</p>`;
            let acDisplay = pc.vtt_data.attributes.ac?.value;
            if (acDisplay === undefined || acDisplay === null) acDisplay = pc.vtt_data.attributes.ac?.flat;
            if (acDisplay === undefined || acDisplay === null) acDisplay = 'N/A';
            statCardsHTML += `<p><strong>AC:</strong> ${acDisplay}</p>`;
            let passivePercFormatted = 'N/A';
            const wisScore = pc.vtt_data.abilities?.wis?.value;
            const percSkillInfo = pc.vtt_data.skills?.prc;
            if (percSkillInfo?.bonuses?.passive !== undefined && percSkillInfo?.bonuses?.passive !== "") {
                passivePercFormatted = percSkillInfo.bonuses.passive;
            } else if (wisScore !== undefined && percSkillInfo?.value !== undefined) {
                passivePercFormatted = calculatePassiveSkill(wisScore, percSkillInfo.value, profBonus);
            }
            statCardsHTML += `<p><strong>Passive Perception:</strong> ${passivePercFormatted}</p>`;
            let passiveInvFormatted = 'N/A';
            const intScore = pc.vtt_data.abilities?.int?.value;
            const invSkillInfo = pc.vtt_data.skills?.inv;
             if (invSkillInfo?.bonuses?.passive !== undefined && invSkillInfo?.bonuses?.passive !== "") {
                passiveInvFormatted = invSkillInfo.bonuses.passive;
            } else if (intScore !== undefined && invSkillInfo?.value !== undefined) {
                 passiveInvFormatted = calculatePassiveSkill(intScore, invSkillInfo.value, profBonus);
            }
            statCardsHTML += `<p><strong>Passive Investigation:</strong> ${passiveInvFormatted}</p>`;
            statCardsHTML += '<h5>Abilities:</h5><ul>';
            abilities.forEach(ablKeyIter => {
                const score = pc.vtt_data.abilities[ablKeyIter.toLowerCase()]?.value || 0;
                const mod = getAbilityModifier(score);
                statCardsHTML += `<li>${ablKeyIter}: ${score} (${mod >= 0 ? '+' : ''}${mod})</li>`;
            });
            statCardsHTML += '</ul><h5>Skills:</h5><ul>';
            if (pc.vtt_data.skills) {
                for (const skillAbbr in pc.vtt_data.skills) {
                    const skill = pc.vtt_data.skills[skillAbbr];
                    if (!skill.ability || !pc.vtt_data.abilities[skill.ability]) continue; 
                    const abilityScoreForSkill = pc.vtt_data.abilities[skill.ability]?.value || 10;
                    const abilityMod = getAbilityModifier(abilityScoreForSkill);
                    let skillMod = abilityMod;
                    const profValue = skill.value; 
                    if (profValue === 1) skillMod += profBonus; 
                    else if (profValue === 2) skillMod += (profBonus * 2); 
                    else if (profValue === 0.5) skillMod += Math.floor(profBonus / 2); 
                    let skillName = skillAbbr.charAt(0).toUpperCase() + skillAbbr.slice(1);
                    skillName = skillName.replace(/([A-Z])/g, ' $1').replace(/(\d+)/g, ' $1').trim();
                    const skillNameMap = {"acr": "Acrobatics", "ani": "Animal Handling", "arc": "Arcana", "ath": "Athletics", "dec": "Deception", "his": "History", "ins": "Insight", "itm": "Intimidation", "inv": "Investigation", "med": "Medicine", "nat": "Nature", "prc": "Perception", "prf": "Performance", "per": "Persuasion", "rel": "Religion", "slt": "Sleight of Hand", "ste": "Stealth", "sur": "Survival"};
                    skillName = skillNameMap[skillAbbr] || skillName;
                    statCardsHTML += `<li>${skillName}: ${skillMod >= 0 ? '+' : ''}${skillMod}</li>`;
                }
            }
            statCardsHTML += '</ul></div>';
        });
        statCardsHTML += `</div>`; 
        dashboardContent.innerHTML += statCardsHTML;
    }

    function toggleAbilityExpansion(ablKey) {
        const selectedPcs = allCharacters.filter(char => activePcIds.has(char._id) && char.character_type === 'PC' && char.vtt_data);
        const expansionDiv = document.getElementById(`expanded-${ablKey}`);
        const headerTH = document.querySelector(`#main-stats-table th[data-ability="${ablKey}"]`);
        const arrowSpan = headerTH ? headerTH.querySelector('span.arrow-indicator') : null;

        if (!expansionDiv || !headerTH || !arrowSpan) { return; }

        const isTargetHidden = expansionDiv.style.display === 'none';

        // If trying to open a new section, close the old one first
        if (isTargetHidden && currentlyExpandedAbility && currentlyExpandedAbility !== ablKey) {
            const otherDiv = document.getElementById(`expanded-${currentlyExpandedAbility}`);
            const otherHeaderTH = document.querySelector(`#main-stats-table th[data-ability="${currentlyExpandedAbility}"]`);
            if (otherDiv) otherDiv.style.display = 'none';
            if (otherHeaderTH) otherHeaderTH.querySelector('span.arrow-indicator').textContent = ' ►';
        }

        // Now toggle the target section
        if (isTargetHidden) {
            if (selectedPcs.length > 0) {
                populateExpandedAbilityDetails(ablKey, expansionDiv, selectedPcs);
                expansionDiv.style.display = 'block';
                arrowSpan.textContent = ' ▼';
                currentlyExpandedAbility = ablKey;
            } else { // No PCs selected, show message in placeholder or do nothing
                expansionDiv.innerHTML = "<p>Select Player Characters to see details.</p>";
                expansionDiv.style.display = 'block'; // Show the message
                arrowSpan.textContent = ' ▼'; // Still indicate it's "open" showing the message
                currentlyExpandedAbility = ablKey; // Track it as open
            }
        } else { // If it was already open (current display is not 'none'), hide it
            expansionDiv.style.display = 'none';
            arrowSpan.textContent = ' ►';
            if (currentlyExpandedAbility === ablKey) {
                currentlyExpandedAbility = null;
            }
        }
    }

    function populateExpandedAbilityDetails(ablKey, expansionDiv, selectedPcsInput) {
        // Sort PCs by the current ability score, descending
        const sortedPcs = [...selectedPcsInput].sort((a, b) => {
            const scoreA = a.vtt_data.abilities[ablKey.toLowerCase()]?.value || 0;
            const scoreB = b.vtt_data.abilities[ablKey.toLowerCase()]?.value || 0;
            return scoreB - scoreA;
        });

        let contentHTML = `<h5>${ablKey} Details & Comparison</h5>`;

        // 1. Bar Chart Container
        contentHTML += `<div class="ability-bar-chart-container">`;
        sortedPcs.forEach(pc => {
            const score = pc.vtt_data.abilities[ablKey.toLowerCase()]?.value || 0;
            const barWidth = (score / 20) * 100;
            contentHTML += `<div class="pc-bar-row"> 
                                <div class="stat-comparison-pc-name" title="${pc.name}">${pc.name.substring(0,15)+(pc.name.length > 15 ? '...' : '')}</div>
                                <div class="stat-bar-wrapper"><div class="stat-bar" style="width: ${barWidth}%;">${score}</div></div>
                           </div>`;
        });
        contentHTML += `</div>`;

        // 2. Derived Stats Table
        contentHTML += `<table class="derived-stats-table"><thead><tr><th>Derived Stat / Skill</th>`;
        sortedPcs.forEach(pc => {
            contentHTML += `<th>${pc.name.substring(0,10)+(pc.name.length > 10 ? '...' : '')}</th>`;
        });
        contentHTML += `</tr></thead><tbody>`;
        
        const derivedStatsMetrics = new Map(); 
        
        const pcLevel = sortedPcs[0] ? (sortedPcs[0].flags?.ddbimporter?.dndbeyond?.totalLevels || 1) : 1;
        const profBonus = getProficiencyBonus(pcLevel);

        // Add standard derived stats first
        derivedStatsMetrics.set("Modifier", { 
            display: "Modifier", 
            isSkill: false,
            calc: (pc, abl) => { const s = pc.vtt_data.abilities[abl.toLowerCase()]?.value || 0; const m = getAbilityModifier(s); return `${m >= 0 ? '+' : ''}${m}`; }
        });
        derivedStatsMetrics.set(`${ablKey} Save`, { 
            display: `${ablKey} Save`, 
            isSkill: false,
            calc: (pc, abl) => {
                const s = pc.vtt_data.abilities[abl.toLowerCase()]?.value || 0;
                const lvl = pc.flags?.ddbimporter?.dndbeyond?.totalLevels || 1; // Use individual PC level
                const pB = getProficiencyBonus(lvl);
                const isProf = pc.vtt_data.abilities[abl.toLowerCase()]?.proficient === 1;
                const sb = savingThrowBonus(s, isProf, pB);
                return `${sb >= 0 ? '+' : ''}${sb} ${isProf ? '(P)' : ''}`;
            }
        });

        // Ability-specific derived stats
        if (ablKey === 'STR') {
            derivedStatsMetrics.set("Carrying Capacity", { display: "Carrying Capacity", isSkill: false, calc: pc => `${carryingCapacity(pc.vtt_data.abilities.str?.value || 0)} lbs`});
            derivedStatsMetrics.set("Push/Drag/Lift", { display: "Push/Drag/Lift", isSkill: false, calc: pc => `${pushDragLift(pc.vtt_data.abilities.str?.value || 0)} lbs`});
            derivedStatsMetrics.set("Long Jump", { display: "Long Jump (Run/Stand)", isSkill: false, calc: pc => `${longJump(pc.vtt_data.abilities.str?.value || 0, true)}ft / ${longJump(pc.vtt_data.abilities.str?.value || 0, false)}ft`});
            derivedStatsMetrics.set("High Jump", { display: "High Jump (Run/Stand)", isSkill: false, calc: pc => `${highJump(pc.vtt_data.abilities.str?.value || 0, true)}ft / ${highJump(pc.vtt_data.abilities.str?.value || 0, false)}ft`});
            derivedStatsMetrics.set("Athletics", {display: "Athletics", isSkill: true, skillAbbr: "ath"});
        } else if (ablKey === 'DEX') {
            derivedStatsMetrics.set("Initiative", { display: "Initiative", isSkill: false, calc: pc => { const ds = pc.vtt_data.abilities.dex?.value || 0; const i = initiative(ds); return `${i >= 0 ? '+' : ''}${i}`; }});
            derivedStatsMetrics.set("Acrobatics", {display: "Acrobatics", isSkill: true, skillAbbr: "acr"});
            derivedStatsMetrics.set("Sleight of Hand", {display: "Sleight of Hand", isSkill: true, skillAbbr: "slt"});
            derivedStatsMetrics.set("Stealth", {display: "Stealth", isSkill: true, skillAbbr: "ste"});
        } else if (ablKey === 'CON') {
            derivedStatsMetrics.set("Hold Breath", { display: "Hold Breath", isSkill: false, calc: pc => `${holdBreath(pc.vtt_data.abilities.con?.value || 0)}`});
            // No direct skills for CON
        } else if (ablKey === 'INT') {
            derivedStatsMetrics.set("Arcana", {display: "Arcana", isSkill: true, skillAbbr: "arc"});
            derivedStatsMetrics.set("History", {display: "History", isSkill: true, skillAbbr: "his"});
            derivedStatsMetrics.set("Investigation", {display: "Investigation", isSkill: true, skillAbbr: "inv"});
            derivedStatsMetrics.set("Nature", {display: "Nature", isSkill: true, skillAbbr: "nat"});
            derivedStatsMetrics.set("Religion", {display: "Religion", isSkill: true, skillAbbr: "rel"});
        } else if (ablKey === 'WIS') {
            derivedStatsMetrics.set("Passive Perception", { display: "Passive Perception (Calc)", isSkill: false, calc: pc => {
                const ws = pc.vtt_data.abilities.wis?.value || 0;
                const ps = pc.vtt_data.skills?.prc;
                const lvl = pc.flags?.ddbimporter?.dndbeyond?.totalLevels || 1;
                const pB = getProficiencyBonus(lvl);
                return calculatePassiveSkill(ws, ps?.value, pB);
            }});
            derivedStatsMetrics.set("Animal Handling", {display: "Animal Handling", isSkill: true, skillAbbr: "ani"});
            derivedStatsMetrics.set("Insight", {display: "Insight", isSkill: true, skillAbbr: "ins"});
            derivedStatsMetrics.set("Medicine", {display: "Medicine", isSkill: true, skillAbbr: "med"});
            derivedStatsMetrics.set("Perception", {display: "Perception", isSkill: true, skillAbbr: "prc"});
            derivedStatsMetrics.set("Survival", {display: "Survival", isSkill: true, skillAbbr: "sur"});
        } else if (ablKey === 'CHA') {
            derivedStatsMetrics.set("Deception", {display: "Deception", isSkill: true, skillAbbr: "dec"});
            derivedStatsMetrics.set("Intimidation", {display: "Intimidation", isSkill: true, skillAbbr: "itm"});
            derivedStatsMetrics.set("Performance", {display: "Performance", isSkill: true, skillAbbr: "prf"});
            derivedStatsMetrics.set("Persuasion", {display: "Persuasion", isSkill: true, skillAbbr: "per"});
            if (sortedPcs.some(pc => pc.vtt_data.attributes?.spellcasting === 'cha')) {
                derivedStatsMetrics.set("Spell Save DC (CHA)", {display: "Spell Save DC (CHA)", isSkill: false, calc: (pc) => {
                     if (pc.vtt_data.attributes?.spellcasting !== 'cha') return 'N/A';
                     const s = pc.vtt_data.abilities.cha?.value || 0;
                     const lvl = pc.flags?.ddbimporter?.dndbeyond?.totalLevels || 1;
                     const pB = getProficiencyBonus(lvl);
                     return spellSaveDC(s, pB);
                }});
                derivedStatsMetrics.set("Spell Attack Bonus (CHA)", {display: "Spell Attack Bonus (CHA)", isSkill: false, calc: (pc) => {
                    if (pc.vtt_data.attributes?.spellcasting !== 'cha') return 'N/A';
                    const s = pc.vtt_data.abilities.cha?.value || 0;
                    const lvl = pc.flags?.ddbimporter?.dndbeyond?.totalLevels || 1;
                    const pB = getProficiencyBonus(lvl);
                    return `+${spellAttackBonus(s, pB)}`;
                }});
            }
        }
        
        derivedStatsMetrics.forEach((metric, metricKeyName) => { // metricKeyName is what we used in set, metric is the object {display, calc, isSkill, skillAbbr}
            contentHTML += `<tr><th>${metric.display}</th>`;
            sortedPcs.forEach(pc => {
                let value = 'N/A';
                if (metric.isSkill) {
                    const skillInfo = pc.vtt_data.skills?.[metric.skillAbbr];
                    const abilityKeyForSkill = skillInfo?.ability;
                    if (skillInfo && abilityKeyForSkill && pc.vtt_data.abilities[abilityKeyForSkill]) {
                        const pcSpecificLevel = pc.flags?.ddbimporter?.dndbeyond?.totalLevels || 1;
                        const pcSpecificProfBonus = getProficiencyBonus(pcSpecificLevel);
                        const baseScore = pc.vtt_data.abilities[abilityKeyForSkill].value || 0;
                        const abilityMod = getAbilityModifier(baseScore);
                        let skillMod = abilityMod;
                        const profValue = skillInfo.value;
                        if (profValue === 1) skillMod += pcSpecificProfBonus;
                        else if (profValue === 2) skillMod += (pcSpecificProfBonus * 2);
                        else if (profValue === 0.5) skillMod += Math.floor(pcSpecificProfBonus / 2);
                        value = `${skillMod >= 0 ? '+' : ''}${skillMod}`;
                    }
                } else {
                    value = metric.calc(pc, ablKey);
                }
                contentHTML += `<td>${value}</td>`;
            });
            contentHTML += `</tr>`;
        });

        contentHTML += `</tbody></table>`;
        expansionDiv.innerHTML = contentHTML;
    }

    // --- UI Control Functions ---
    function setupInterfaceControls() { /* ... (Same as before) ... */ }
    // --- Full Functions for CRUD and Dialogue ---
    async function createCharacter() { /* ... (Same as before) ... */ }
    async function saveGMNotes() { /* ... (Same as before) ... */ }
    function renderMemories(memories) { /* ... (Same as before) ... */ }
    async function addMemoryToCharacter(content = null, type = null) { /* ... (Same as before) ... */ }
    async function deleteMemory(memoryId) { /* ... (Same as before) ... */ }
    async function generateDialogue() { /* ... (Same as before) ... */ }
    function addDialogueToTranscript(text, type) { /* ... (Same as before) ... */ }
    function renderAISuggestions(memorySuggestions, topicSuggestions) { /* ... (Same as before) ... */ }
    function populateAddMemoryForm(content, type) { /* ... (Same as before) ... */ }

    // Re-pasting the complete functions for clarity from your previous correct version
    function setupInterfaceControls() {
        const resizer = getElem('resizer');
        const leftColumn = getElem('left-column');
        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const startX = e.clientX;
            const startWidth = leftColumn.offsetWidth;
            const handleMouseMove = (moveEvent) => {
                const newWidth = startWidth + (moveEvent.clientX - startX);
                leftColumn.style.width = `${newWidth}px`;
            };
            const handleMouseUp = () => {
                window.removeEventListener('mousemove', handleMouseMove);
                window.removeEventListener('mouseup', handleMouseUp);
            };
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        });
        document.querySelectorAll('.collapsible-section h3').forEach(header => {
            header.addEventListener('click', () => {
                header.parentElement.classList.toggle('collapsed');
            });
        });
    }
    
    // --- Window Onload ---
    window.onload = () => {
        console.log("window.onload triggered. Calling fetchCharacters...");
        fetchCharacters();
        setupInterfaceControls();
        if (!selectedNpcId) {
            updateView();
        }
    };
</script>

</body>
</html>